#include <NdGameSdk/sdkregenny.hpp>
#include <NdGameSdk/sdkstringid.hpp>

type int 4 [[i32]]
type uint64_t 8 [[u64]]
type uintptr_t 8 [[u64]]
type uint128_t 16 [[u128]]
type vec4 16 [[u128]]
type uint32_t 4 [[u32]]
type size_t 8 [[u32]]
type uint16_t 2 [[u16]]
type uint8_t 1 [[u8]]
type bool 1 [[bool]]
type void 0
type char 1
type float 4 [[f32]]
type double 8
type StringId64 8 [[u64]]
   
namespace regenny {

    // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src
    namespace shared {
        
        // Forward declared structures.
        namespace ndlib {
            struct FrameParams{};

            namespace render {
                struct WindowContext{};
            }

            namespace script {
                struct ScriptModule{};
             }
        }

        namespace gamelib {
            namespace state_script {
                struct ScriptCFuncContext{};
            }
        }

        // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\corelib
        namespace corelib {

            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\corelib\memory
            namespace memory {

                enum Context : uint32_t {
                    kAllocInvalid = 0x0,
                    kAllocUnknown = 0x1,
                    kAllocSystemDirect = 0x2,
                    kAllocSystemFlexible = 0x3,
                    kAllocSystemDevelopment = 0x4,
                    kAllocAppCpu = 0x5,
                    kAllocAppCpuLargePage = 0x6,
                    kAllocAppGpu = 0x7,
                    kAllocAppGpuLargePage = 0x8,
                    kAllocAppFlex = 0x9,
                    kAllocDevCpu = 0xA,
                    kAllocDevCpuLargePage = 0xB,
                    kAllocDevGpu = 0xC,
                    kAllocDevCpuAlways = 0xD,
                    kAllocAnimation = 0xE,
                    kAllocWrappedMalloc = 0xF,
                    kAllocDebugDevMenu = 0x10,
                    kAllocSingleGameFrame = 0x11,
                    kAllocDoubleGameFrame = 0x12,
                    kAllocDoubleGameplayUpdate = 0x13,
                    kAllocGpuStaticRenderTarget = 0x14,
                    kAllocGpuStaticTexture = 0x15,
                    kAllocGpuTexture = 0x16,
                    kAllocGpuTextureStaging = 0x17,
                    kAllocGpuTextureStagingShadow = 0x18,
                    kAllocGpuLevelTexture = 0x19,
                    kAllocGpuLut = 0x1A,
                    kAllocGpuBuffer = 0x1B,
                    kAllocGpuClothRoBuffer = 0x1C,
                    kAllocGpuClothRwBuffer = 0x1D,
                    kAllocGpuDeformerBuffer = 0x1E,
                    kAllocGpuExposureMapBuffer = 0x1F,
                    kAllocGpuExposureMapHeightMaps = 0x20,
                    kAllocGpuDynamicRenderTarget = 0x21,
                    kAllocDevGpuOverflowRenderTa = 0x22,
                    kAllocGpuShader = 0x23,
                    kAllocGpuDebugShader = 0x24,
                    kAllocScriptData = 0x25,
                    kAllocMenu = 0x26,
                    kAllocNetwork = 0x27,
                    kAllocNetworkProcess = 0x28,
                    kAllocMovie = 0x29,
                    kAllocDebugAudioBin = 0x2A,
                    kAllocDebugVoxBin = 0x2B,
                    kAllocVoxTables = 0x2C,
                    kAllocAudioEffects = 0x2D,
                    kAllocArmWorkData = 0x2E,
                    kAllocPhysics = 0x2F,
                    kAllocPhysicsPersistent = 0x30,
                    kAllocPhysicsOverflow = 0x31,
                    kAllocPhysicsSingleFrame = 0x32,
                    kAllocPhysicsDoubleBuffer = 0x33,
                    kAllocDebugPhysicsSingleFrame = 0x34,
                    kAllocParticleDesc = 0x35,
                    kAllocParticleManager = 0x36,
                    kAllocParticleRuntime = 0x37,
                    kAllocProcess = 0x38,
                    kAllocLipsync = 0x39,
                    kAllocWater = 0x3A,
                    kAllocGui2 = 0x3B,
                    kAllocGui2GpuTexture = 0x3C,
                    kAllocIcon = 0x3D,
                    kAllocGui2_ = 0x3E,
                    kAllocText2Font = 0x3F,
                    kAllocCustom = 0x40,
                    kAllocAlignCache = 0x41,
                    kAllocGestureCache = 0x42,
                    kAllocIkData = 0x43,
                    kAllocNdgi = 0x44,
                    kAllocRenderPool = 0x45,
                    kAllocNdrg = 0x46,
                    kAllocDebugBlockmeshMgr = 0x47,
                    kAllocGameToGpuRing = 0x48,
                    kAllocDoubleGameToGpuRing = 0x49,
                    kAllocRenderToGpuRing = 0x4A,
                    kAllocDoubleRenderToGpuRing = 0x4B,
                    kAllocGameToGpuResourceRing = 0x4C,
                    kAllocRenderToGpuResourceRing = 0x4D,
                    kAllocDevGameToGpuRing = 0x4E,
                    kAllocDevRenderToGpuRing = 0x4F,
                    kAllocDevGameToGpuResourceRing = 0x50,
                    kAllocDevRenderToGpuResource = 0x51,
                    kAllocCpuAccessOnlyRingTag = 0x52,
                    kAllocDoubleCpuAccessOnlyRin = 0x53,
                    kAllocGpuUploadRingTag = 0x54,
                    kAllocGpuReadbackRingTag = 0x55,
                    kAllocSingleRenderFrame = 0x56,
                    kAllocRenderGlobals = 0x57,
                    kAllocPsoCacheTag = 0x58,
                    kAllocConstBufferMgr = 0x59,
                    kAllocPackagePageHdrs = 0x5A,
                    kAllocNpcGlobals = 0x5B,
                    kAllocPathfindManager = 0x5C,
                    kAllocRainMgr = 0x5D,
                    kAllocHud = 0x5E,
                    kAllocDevMenuLowMem = 0x5F,
                    kAllocProcessMgr = 0x60,
                    kAllocComponentMgr = 0x61,
                    kAllocPlayerGlobals = 0x62,
                    kAllocClothCompute = 0x63,
                    kAllocEventQueueScript = 0x64,
                    kAllocEventQueueBucket = 0x65,
                    kAllocEventQueueMenu = 0x66,
                    kAllocVoxRequest = 0x67,
                    kAllocPsarcStatic = 0x68,
                    kAllocPsarcDynamic = 0x69,
                    kAllocVegetation = 0x6A,
                    kAllocScreamPluginEventQueue = 0x6B,
                    kAllocWavetableSynth = 0x6C,
                    kAllocLodManager = 0x6D,
                    kAllocDeltaBitstream = 0x6E,
                    kMaxNumContexts = 0x6F,
                    kAllocSingleFrame = 0x70,
                    kAllocGpuRing = 0x71,
                    kAllocRenderResourceRingTag = 0x72,
                    kAllocDoubleGpuRing = 0x73,
                    kAllocDevGpuRing = 0x74,
                    kAllocDevRenderResourceRing = 0x75,
                }; // 0x142fcf750

                enum MapId : uint32_t {
                    ALLOCATION_PRX_DIRECT_MEM = 0x01,
                    ALLOCATION_APP_CPU_LARGE_PAGE_MEMORY = 0x02,
                    ALLOCATION_CPU_MEMORY = 0x03,
                    ALLOCATION_APP_GPU_LARGE_PAGE_MEMORY = 0x04,
                    ALLOCATION_GPU_MEMORY = 0x05,
                    ALLOCATION_REQUIRED_PRX_FLEX_MEM = 0x06,
                    ALLOCATION_CODE_AND_DATA = 0x07,
                    ALLOCATION_THREAD_CONTEXTS = 0x08,
                    ALLOCATION_PRX_FLEX_MEM = 0x09,
                    ALLOCATION_APP_FLEX_MEM = 0x0A,
                    ALLOCATION_DEV_CODE_AND_DATA = 0x0B,
                    ALLOCATION_DEV_PRX_MEM = 0x0C,
                    ALLOCATION_DEV_CPU_MEM = 0x0D,
                    ALLOCATION_DEV_CPU_LARGE_PAGE_MEMORY = 0x0E,
                    ALLOCATION_DEV_GPU_MEM = 0x0F,
                    ALLOCATION_SCOPED_TEMP_ALLOCS = 0x21,
                    ALLOCATION_SCREAM_SND_MEM_USE_STREAMING = 0x7A,
                    ALLOCATION_SCREAM_SOUND_BANK_HEAP = 0x7B,
                    ALLOCATION_AUDIO_EFFECTS = 0x43,
                    ALLOCATION_LOADING_HEAP = 0x55,
                    ALLOCATION_LOADING_HEAP_HIDDEN = 0x56,
                    ALLOCATION_PSO_PRE_LOADING_HEAP = 0x59,
                    ALLOCATION_PROCESS_HEAP = 0x6F,
                    ALLOCATION_ANIMATION_HEAP = 0x71,
                    ALLOCATION_NETWORK_HEAP = 0x91,
                    ALLOCATION_NDGI_HEAP = 0xAE,
                    ALLOCATION_RENDER_POOL_HEAP = 0xB0,
                    ALLOCATION_PHYSICS_MEMORY = 0x6B,
                    ALLOCATION_ICON = 0xCF,
                    ALLOCATION_GUI2 = 0xA1,
                    ALLOCATION_GUI2_STREAMING = 0xA2,
                    ALLOCATION_GUI2_PRIMITIVE_HEAP = 0xA3,
                    ALLOCATION_TEXT2_FONT = 0xA0,
                    ALLOCATION_WAVETABLE_SYNTH = 0xA5,
                    ALLOCATION_TAGGED_HEAP = 0x23,
                    ALLOCATION_SINGLE_GAME_FRAME = 0x25,
                    ALLOCATION_DOUBLE_GAME_FRAME = 0x26,
                    ALLOCATION_DOUBLE_GAMEPLAY_UPDATE = 0x27,
                    ALLOCATION_SINGLE_RENDER_FRAME = 0xB1,
                    ALLOCATION_GAME_TO_GPU_RING = 0xB2,
                    ALLOCATION_DOUBLE_GAME_TO_GPU_RING = 0xB3,
                    ALLOCATION_RENDER_TO_GPU_RING = 0xB4,
                    ALLOCATION_DOUBLE_RENDER_TO_GPU_RING = 0xB5,
                    ALLOCATION_RESOURCES_TO_GPU_RING = 0xB6,
                    ALLOCATION_CPU_ACCESS_ONLY_RING = 0xB8,
                    ALLOCATION_SHADER = 0xC7,
                    ALLOCATION_TEXTURE_READING = 0xDA,
                    ALLOCATION_APP_CPU_LARGE_PAGE_UNACCOUNTED = 0x10,
                    ALLOCATION_APP_CPU_LARGE_PAGE_FREE = 0x11,
                    ALLOCATION_WRAPPED_MALLOC_POOL = 0x22,
                    ALLOCATION_IK_DATA = 0x53,
                    ALLOCATION_MENU_HEAP = 0x5E,
                    ALLOCATION_MUSIC_MGR = 0x5F,
                    ALLOCATION_PARTICLE_DESC = 0x68,
                    ALLOCATION_PARTICLE_MGR = 0x69,
                    ALLOCATION_PARTICLE_RUNTIME = 0x6A,
                    ALLOCATION_PHYSICS_PERSIST = 0x6C,
                    ALLOCATION_PRINTF_STATIC_BUFFER_MEM = 0x6D,
                    ALLOCATION_TEXTDB_MEM = 0x8F,
                    ALLOCATION_DYNAMIC_LIGHT_MEM = 0xAB,
                    ALLOCATION_FIOS_MEM_POOL = 0x50,
                    ALLOCATION_PACKAGE_ARRAY = 0x65,
                    ALLOCATION_PACKAGE_PAGE_HEADERS = 0x67,
                    ALLOCATION_CBUFFER_MGR = 0x46,
                    ALLOCATION_FONTS = 0x51,
                    ALLOCATION_LEVEL_DEFS = 0x5A,
                    ALLOCATION_LEVEL_STREAMING_MGR = 0x5B,
                    ALLOCATION_LVLMGR = 0x5C,
                    ALLOCATION_SCRIPT_HEAP = 0x80,
                    ALLOCATION_SCRIPT_RELOC_HEAP = 0x83,
                    ALLOCATION_SCRIPT_STACK_FRAMES = 0x84,
                    ALLOCATION_SCRIPT_SCOPED_ALLOCATIONS = 0x85,
                    ALLOCATION_SCRIPT_SYMBOL_TBL = 0x86,
                    ALLOCATION_PROCESS_MGR = 0x6E,
                    ALLOCATION_TASK_GRAPH = 0x8E,
                    ALLOCATION_MESH_RAY_CASTER = 0xAD,
                    ALLOCATION_ARM_PROCESS = 0x3E,
                    ALLOCATION_ARM_PUSHBUFFER = 0x3F,
                    ALLOCATION_ARM_WORKDATA = 0x40,
                    ALLOCATION_SCREAM_SND_MEM_USE_SYNTH = 0x77,
                    ALLOCATION_SCREAM_SND_MEM_USE_SCRIPTING = 0x78,
                    ALLOCATION_SCREAM_SND_MEM_USE_CCS = 0x79,
                    ALLOCATION_SCREAM_SOUND_BANK_DS_HEAP = 0x7C,
                    ALLOCATION_SCREAM_PLUGIN_EVENT_QUEUE_HEAP = 0x7F,
                    ALLOCATION_SOUND_VIRTUAL_BANK = 0x8D,
                    ALLOCATION_NCA_BATCH = 0x60,
                    ALLOCATION_VIBRATION_MANAGER = 0xA4,
                    ALLOCATION_HTTP_POOL_SIZE = 0x34,
                    ALLOCATION_FG_ANIM_DATA = 0x49,
                    ALLOCATION_FG_ANIM_IDENTITY_MATS = 0x4A,
                    ALLOCATION_FG_DRAW_DATA = 0x4C,
                    ALLOCATION_FG_ANIMCMD_DATA = 0x4B,
                    ALLOCATION_HUD = 0x52,
                    ALLOCATION_SAVE_MANAGER = 0x75,
                    ALLOCATION_SAVE_CHECKPOINT = 0x74,
                    ALLOCATION_BODY_MANAGER = 0x44,
                    ALLOCATION_LIP_SYNC_BUFFER = 0x54,
                    ALLOCATION_WATER = 0xCE,
                    ALLOCATION_RENDER_GLOBALS = 0x72,
                    ALLOCATION_PSO_CACHE = 0xD9,
                    ALLOCATION_REDIS = 0x38,
                    ALLOCATION_DMENU_LOWMEM = 0x47,
                    ALLOCATION_AUDIO_VOX = 0x41,
                    ALLOCATION_AUDIO_VOX_TABLES = 0x42,
                    ALLOCATION_SIMPLE_NPC = 0x8B,
                    ALLOCATION_VEGETATION = 0x94,
                    ALLOCATION_GAME_CONFIG = 0x95,
                    ALLOCATION_ANIM_STREAMING = 0x96,
                    ALLOCATION_ANIM_CHAIN = 0x97,
                    ALLOCATION_ANIM_DUMMY_INSTANCE = 0x98,
                    ALLOCATION_REGION_TAG_TABLE = 0x9A,
                    ALLOCATION_RAIN_MGR = 0x9D,
                    ALLOCATION_CINEMATICS = 0x9E,
                    ALLOCATION_EVENT_QUEUE_SCRIPT_HEAP = 0x28,
                    ALLOCATION_EVENT_QUEUE_BUCKET_HEAP = 0x29,
                    ALLOCATION_EVENT_QUEUE_MENU_HEAP = 0x2A,
                    ALLOCATION_VOX_REQUEST_HEAP = 0x2B,
                    ALLOCATION_FRAME_PARAMS = 0x2F,
                    ALLOCATION_PREFETCH_BUFFER = 0x30,
                    ALLOCATION_TEXTURE_DICT = 0xD7,
                    ALLOCATION_TEXTURE_REPORTER = 0xD0,
                    ALLOCATION_GESTURE_CACHE = 0x99,
                    ALLOCATION_RESOURCE_TABLE = 0x3B,
                    ALLOCATION_NDRG_HEAP = 0xAF,
                    ALLOCATION_ANIM_ALIGN_CACHE = 0x3D,
                    ALLOCATION_COMPONENT_MGR = 0x89,
                    ALLOCATION_SUBSYSTEM_HEAP = 0x8A,
                    ALLOCATION_STATE_SCRIPT = 0x87,
                    ALLOCATION_SMOKE_TEST = 0x8C,
                    ALLOCATION_FIOS_STATIC_PSARC = 0xD5,
                    ALLOCATION_FIOS_DYNAMIC_PSARC = 0xD6,
                    ALLOCATION_SETTINGS_POOL = 0x88,
                    ALLOCATION_LVLMGR_NAME_CACHE = 0x5D,
                    ALLOCATION_PACKAGE_MGR_RING_BUFFER = 0x66,
                    ALLOCATION_NP_POOL_1 = 0x35,
                    ALLOCATION_NP_POOL_2 = 0x36,
                    ALLOCATION_HTTP_CACHE = 0x33,
                    ALLOCATION_PLAYGO_HEAP = 0x9B,
                    ALLOCATION_NAV_MESH_MANAGER = 0x61,
                    ALLOCATION_NPC_GLOBALS = 0x62,
                    ALLOCATION_PATHFIND_MANAGER = 0x63,
                    ALLOCATION_FIOS_DEARCHIVER_MEM = 0x31,
                    ALLOCATION_PLAYER_GLOBALS = 0x90,
                    ALLOCATION_RIGIDBODY_DATA = 0x73,
                    ALLOCATION_EVENT_LOG = 0x9C,
                    ALLOCATION_CATMULL_ROM = 0x45,
                    ALLOCATION_FACTS = 0x48,
                    ALLOCATION_PHOTO_MODE = 0x93,
                    ALLOCATION_PAD = 0x3C,
                    ALLOCATION_WIDGET_MANAGER = 0xA6,
                    ALLOCATION_GUI2_GPU = 0xD8,
                    ALLOCATION_CLOTH_COMPUTE = 0xD4,
                    ALLOCATION_LOD_MANAGER = 0xA9,
                    ALLOCATION_VOL_PROBE_LIGHT_CACHE = 0xAA,
                    ALLOCATION_APP_CPU_UNACCOUNTED = 0x12,
                    ALLOCATION_APP_CPU_FREE = 0x13,
                    ALLOCATION_STATIC_TEXTURE = 0xC2,
                    ALLOCATION_TEXTURE = 0xC3,
                    ALLOCATION_GUI2_TEXTURE = 0xC6,
                    ALLOCATION_TEXTURE_STAGING = 0xC4,
                    ALLOCATION_LEVEL_TEXTURE = 0xC5,
                    ALLOCATION_GPU_UPLOAD_RING = 0xB9,
                    ALLOCATION_CLOTH_RO_BUFFER = 0xCA,
                    ALLOCATION_CLOTH_RW_BUFFER = 0xCB,
                    ALLOCATION_GPU_READBACK_RING = 0xBA,
                    ALLOCATION_EXPOSURE_MAP_BUFFER = 0xCC,
                    ALLOCATION_EXPOSURE_MAP_HEIGHTMAPS = 0xCD,
                    ALLOCATION_APP_GPU_UNACCOUNTED = 0x14,
                    ALLOCATION_APP_GPU_FREE = 0x15,
                    ALLOCATION_STATIC_RENDER_TARGET = 0xBB,
                    ALLOCATION_STATIC_NON_RENDER_TARGET = 0xBC,
                    ALLOCATION_STATIC_BUFFER = 0xBD,
                    ALLOCATION_DYNAMIC_RENDER_TARGET = 0xBE,
                    ALLOCATION_DYNAMIC_NON_RENDER_TARGET = 0xBF,
                    ALLOCATION_DYNAMIC_BUFFER = 0xC0,
                    ALLOCATION_LUT = 0xC1,
                    ALLOCATION_DEFORMER_BUFFER = 0xC9,
                    ALLOCATION_RENDER_BUFFER = 0xC8,
                    ALLOCATION_LUT_TABLE = 0xAC,
                    ALLOCATION_APP_GPU_UNACCOUNTED = 0x16,
                    ALLOCATION_APP_GPU_FREE = 0x17,
                    ALLOCATION_JOB_SYSTEM = 0x20,
                    ALLOCATION_FIOS_RAM_CACHE = 0xD1,
                    ALLOCATION_FIOS_PREFETCHER = 0xD3,
                    ALLOCATION_APP_FLEX_UNACCOUNTED = 0x18,
                    ALLOCATION_APP_FLEX_FREE = 0x19,
                    ALLOCATION_OVERFLOW_LOADING_HEAP = 0xE5,
                    ALLOCATION_DEBUG_LOADING_HEAP = 0xE7,
                    ALLOCATION_DEBUG_PSO_PRE_LOADING_HEAP = 0xE9,
                    ALLOCATION_DEBUG_SHADER = 0xEA,
                    ALLOCATION_DEV_CPU_UNACCOUNTED = 0x1A,
                    ALLOCATION_DEV_CPU_FREE = 0x1B,
                    ALLOCATION_TAGGED_DEV_HEAP = 0x24,
                    ALLOCATION_DEV_RESOURCES_TO_GPU_RING = 0xF3,
                    ALLOCATION_DEBUG_SCREAM_DEBUG = 0xDB,
                    ALLOCATION_DEBUG_SCREAM_SERVER_TTY = 0xDC,
                    ALLOCATION_DEBUG_SCREAM_SERVER_AUDITIONING = 0xDD,
                    ALLOCATION_DEBUG_AUDIO_BIN = 0xDF,
                    ALLOCATION_DEBUG_VOX_BIN = 0xE0,
                    ALLOCATION_PHYSICS_OVERFLOW_MEMORY = 0xE1,
                    ALLOCATION_PROCESS_HEAP_OVERFLOW = 0x70,
                    ALLOCATION_SID_DB = 0x3A,
                    ALLOCATION_PROFILE_SAMPLE_BUFFERS = 0x2C,
                    ALLOCATION_PROFILE_GPU_SAMPLE_BUFFERS = 0x2D,
                    ALLOCATION_PROFILE_CMP_SAMPLE_BUFFERS = 0x2E,
                    ALLOCATION_SCRIPT_MGR_DECI_INPUT = 0x82,
                    ALLOCATION_SCRIPT_DBG_HEAP = 0x81,
                    ALLOCATION_NPC_DEBUG_MEM = 0xE4,
                    ALLOCATION_DEBUG_DMENU = 0xEE,
                    ALLOCATION_DEBUG_ORBIS_EXCEPTION = 0xEF,
                    ALLOCATION_DEBUG_DRAWING = 0xF0,
                    ALLOCATION_MEMORY_TRACKER = 0x32,
                    ALLOCATION_DEV_GAME_TO_GPU_RING = 0xF1,
                    ALLOCATION_DEV_RENDER_TO_GPU_RING = 0xF2,
                    ALLOCATION_PROFILE_TRACE = 0x9F,
                    ALLOCATION_TEXTDB_DEBUG_MEM = 0xF4,
                    ALLOCATION_DEV_SCREEN_CAPTURE = 0xF5,
                    ALLOCATION_FIOS_RAM_CACHE_PERSISTENT = 0xD2,
                    ALLOCATION_DEBUG_BLOCKMESH_MGR = 0xF6,
                    ALLOCATION_DEBUG_TOOLS_MGR = 0xF7,
                    ALLOCATION_DEV_CPU_UNACCOUNTED = 0x1C,
                    ALLOCATION_DEV_CPU_FREE = 0x1D,
                    ALLOCATION_DEV_GPU_TARGET_CAPTURE = 0xEB,
                    ALLOCATION_PS_CAMERA = 0xEC,
                    ALLOCATION_OVERFLOW_DYNAMIC_RENDER_TARGET = 0xF8,
                    ALLOCATION_OVERFLOW_DYNAMIC_NON_RENDER_TARGET = 0xF9,
                    ALLOCATION_OVERFLOW_DYNAMIC_BUFFER = 0xFA,
                    ALLOCATION_DEV_GPU_UNACCOUNTED = 0x1E,
                    ALLOCATION_DEV_GPU_FREE = 0x1F
                }

                struct MemoryMapEntry 0x20 {
                    MapId m_id
                    Context m_context
                    uint64_t m_size
                    uint64_t m_aligned
                    char* m_name [[utf8*]]
                }

                struct Allocator 0x60 {

                    struct VTable {
                        virtual uint64_t PostAllocate(uint64_t pSize, uint64_t pAlignment, char* pFunction, uint32_t pLine, char* pFilePath) @ 7;
                    };

                    VTable* vftable;
                    uint16_t m_flags @ 0x30;
                    uint8_t m_state;
                    void* m_pTracker @ 0x38;
                    char* m_contextName [[utf8*]];
                    StringId64 m_contextHash;
                    bool m_initialized;
                };

                struct HeapArena 0x50 {
                    uint8_t* m_pMemory;
                    uint8_t* m_current;
                    uint64_t m_sizeFlags;
                    uint64_t m_peakUsage;
                    uint64_t m_lock;
                    uint64_t m_waiterCount;
                    void* m_waitListHead;
                    void* m_waitListTail;
                    bool m_lockEnabled;
                    uint64_t m_userTag @ 0x48;
                };

                struct HeapAllocatorWithOverflow : Allocator 0x100 {
                    HeapArena m_HeapArena;
                    void* m_Data @ 0xb0;
                    uint64_t m_size @ 0xc8;
                };

                struct HeapAllocator : HeapAllocatorWithOverflow 0x120 {
                    uint64_t m_fieldd0;
                    uint64_t m_fielde8 @ 0xe8;
                    char* m_file @ 0x100 [[utf8*]];
                    char* m_function [[utf8*]];
                    uint32_t m_line;
                    bool m_field114;
                };

                struct PoolAllocator : Allocator 0xe0 {

                    struct PoolStack 0x68 {
                        uint32_t m_guard0;
                        uint32_t m_guard1;
                        uint32_t m_ticket;
                        void* m_chunkHead @ 0x10;
                        void* m_chunkFree;
                        void* m_blockStart;
                        uint32_t m_blockSize;
                        uint32_t m_lastOffset;
                        uint32_t m_activeCount;
                        uint32_t m_alignment;
                        uint32_t m_freeCount;
                        uint32_t m_hasBlock;
                        uint32_t m_hasTail;
                        uint32_t m_lastTicketIdx;
                        uint64_t m_waitListLock;
                        uint8_t m_waitListEnabled;
                    };

                    PoolStack m_stack;
                    void* m_mem @ 0xd0;
                    uint64_t m_size;
                };

                struct AllocStack 0x50 {
                    void* m_StackPool;
                    bool m_field30 @ 0x30;
                }; // s_AllocStack

            }

            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\corelib\util
            namespace util {

                struct Err {

                    enum ErrDomain : uint16_t {
                        CRT = 0x000, // C runtime strerror/errno
                        AuxDefault = 0x4F1, // general aux family
                        AuxEnvironment = 0x4F2, // environment/config
                        AuxDatabase = 0x4F3, // SQL/DB
                        AuxMessageIPC = 0x4F4, // messaging / IPC
                        CgfxCompiler = 0x4F5, // CgFX compiler (callback-capable)
                        AuxGameContent = 0x4F6, // gameplay/content/assets
                        AuxAudio = 0x4F7, // audio/voice/haptics
                        AuxReserved = 0x4F8, // reserved aux domain
                        AuxUnknown = 0x4F9, // unknown aux domain
                        PosixSocket = 0x701, // POSIX / sockets (errno/Winsock-like)
                    };
                    
                    // ---- AuxDefault (0x4F1) subcodes ----
                    enum ErrAuxDefaultError : uint16_t { 
                        AuxDefault_GeneralError = 0x0000,
                        AuxDefault_WrongState = 0x0001,
                        AuxDefault_BadData = 0x0002,
                        AuxDefault_Abort = 0x0003,
                        AuxDefault_OutOfMemory = 0x0004,
                        AuxDefault_NotFound = 0x0005,
                        AuxDefault_NotInitialized = 0x0006,
                        AuxDefault_AlreadyInitialized = 0x0007,
                        AuxDefault_InvalidArgument = 0x0008, 
                        AuxDefault_OutOfFios2FileHandles = 0x0009,
                        AuxDefault_OutOfFios2OpHandles = 0x000A,
                    };
                    
                    enum ErrAuxDefaultSuccess : uint16_t {
                        AuxDefault_SuccessWithWarning = 0x0000,
                        AuxDefault_SuccessAuxDefault = 0x0001,
                        AuxDefault_InProgress = 0x0002,
                        AuxDefault_UnknownDefaultSuccess = 0x0003,
                    };

                    // ---- AuxEnvironment (0x4F2) ----
                    enum ErrEnvSuccess : uint16_t { Env_Success = 0x0000 };
                    enum ErrEnvError : uint16_t { Env_UnknownError = 0x0000 };

                    // ---- AuxDatabase (0x4F3) ----
                    enum ErrDBSuccess : uint16_t { DB_Success = 0x0000 };
                    enum ErrDBError : uint16_t {
                        DB_GenericFailure = 0x0000,
                        DB_CannotConnect = 0x0001,
                        DB_TooManyRecords = 0x0002,
                        DB_UnknownError = 0x0003,
                    };

                    // ---- AuxMessage / IPC (0x4F4) ---
                    enum ErrMsgIPCSuccess : uint16_t { MsgIPC_ResponseReceivedForMessage = 0x0000 };
                    enum ErrMsgIPCError : uint16_t {
                        MsgIPC_SocketUnspecified = 0x0000,
                        MsgIPC_NoMessageAvailable = 0x0001,
                        MsgIPC_MustReplyBeforeMore = 0x0002,
                        MsgIPC_SpecialCharUnrecognized = 0x0003,
                        MsgIPC_ReplyTimeoutExceeded = 0x0004,
                        MsgIPC_OutgoingBufferFull = 0x0005,
                        MsgIPC_IncomingBufferUnderrun = 0x0006,
                        MsgIPC_ReadStringBufferTooSmall = 0x0007,
                        MsgIPC_DoubleResponseAttempt = 0x0008,
                        MsgIPC_InvalidMessageId = 0x0009,
                        MsgIPC_ResponseForOtherMessage = 0x000A,
                        MsgIPC_ExtraResponsesSent = 0x000B,
                    };

                    // ---- CgFX (0x4F5) ----
                    enum ErrCgfxSuccess : uint16_t { Cgfx_Success = 0x0000 };
                    enum ErrCgfxError : uint16_t { Cgfx_GenericError = 0x0000 };

                    // ---- AuxGameContent (0x4F6) ----
                    enum ErrGameSuccess : uint16_t { Game_Success = 0x0000 };
                    enum ErrGameError : uint16_t {
                        Game_MissingLevelOrPackage = 0x0000,
                        Game_AnimActorSymbolNotFound = 0x0001,
                        Game_AnimActorLoginFailed = 0x0002,
                        Game_ArtGroupNotFound = 0x0003,
                        Game_ScriptIdNotFound = 0x0004,
                        Game_PhysicsInitNoCollision = 0x0005,
                        Game_MissingSpawner = 0x0006,
                        Game_MissingStateScript = 0x0007,
                        Game_MeshNotLoaded = 0x0008,
                        Game_SkeletonNotLoaded = 0x0009,
                        Game_SpawningSuppressed = 0x000A,
                    };

                    // ---- AuxAudio (0x4F7) ----
                    enum ErrAudioSuccess : uint16_t { Audio_UnknownSuccess = 0x0000 };
                    enum ErrAudioError : uint16_t {
                        Audio_UnknownError = 0x0000,
                        Audio_AudioNotEnabled = 0x0001,
                        Audio_SystemNotInitialized = 0x0002,
                        Audio_SystemAlreadyInitialized = 0x0003,
                        Audio_AudioSystemNotStarted = 0x0004,
                        Audio_OutOfSynths = 0x0005,
                        Audio_OutOfVoices = 0x0006,
                        Audio_InvalidVibrationHandle = 0x0007,
                        Audio_InvalidVoiceHandle = 0x0008,
                        Audio_InvalidPlugin = 0x0009,
                        Audio_InvalidOscillator = 0x000A,
                        Audio_InvalidArgument = 0x000B,
                    };

                    uint32_t m_code; // ND code
                    uint32_t m_winCode; // Win32 code
                    void* m_payload;
                };
                
                struct MsgCon 0x40 {

                    enum MsgOutput : uint32_t {
                        kDefault = 0x0,
                        kStdOut = 0x1,
                        kStdconAuto = 0x2,
                        kStdconPersistent = 0x3,
                        kStdconPauseable = 0x4,
                        kStdconNonPauseable = 0x5,
                        kStdconNotRecorded = 0x6,
                        kStdconHost = 0x7,
                        kError = 0x8,
                        kAudio = 0x9,
                        kProcess = 0xa,
                        kCamera = 0xb,
                        kAnimation = 0xc,
                        kAI = 0xd,
                        kParticles = 0xe,
                        kIO = 0xf,
                        kHud = 0x15,
                        kNet = 0x16,
                        kNet2 = 0x17,
                        kHavok = 0x18,
                        kDialogue = 0x19,
                        kMelee = 0x1a,
                        kCinematic = 0x1b,
                        kSave = 0x1c,
                        kGraphics = 0x1d,
                        kMusic = 0x1e,
                        kFoliage = 0x1f,
                        kLogStream = 0x20,
                        kUnknown21 = 0x21,
                        kJafAnim = 0x22
                    };

                    void* vftable;
                    float m_MsgConScale @ 0x10;
                    uint32_t m_MsgConLeftPad;
                    uint32_t m_MsgConHorizontalSize;
                    uint32_t m_MsgConVerticalSize;
                    uint32_t m_MsgConTopPad;
                    uint32_t m_scrollDelta;
                    uint32_t m_scrollPos;
                    bool m_scrollActive;
                    bool m_PrintTimeInTTY @ 0x2e;
                    bool m_PrintTTY @ 0x30;
                    bool m_RedisTTY;
                    bool m_DrawRedisTTYTimes;
                    bool m_DrawRedisTTYStatus;
                    bool m_field34;
                    bool m_ApplyMsgConScaletoDebugText @ 0x36;
                    bool m_EnableMsgConLineWrap;
                    bool m_EnableMsgConAutoResize;
                    bool m_ShowCacheMissesDebugText;
                };
            }

            // c:\branches\discbot??\t1x-pc-?.?.?\shared\src\corelib\containers
            namespace containers {
                
                struct TaggedHeap 0xDB308 {
                    struct VTable {
                        virtual uint64_t GetBlockSize() @ 0x30
                    } 
                    VTable* vftable;
                }

                struct FixedSizeHeap 0x58 {
                    void* m_pData;
                    void* m_pUsageAlloc;
                    uint64_t* m_pUsage;
                    uint64_t m_capacity;
                    uint64_t m_capacityAligned;
                    uint32_t m_usageWordCount;
                    uint64_t m_numElements @ 0x30;
                    uint64_t m_elementSize;
                    uint64_t m_activeCount;
                    uint64_t m_alignment;
                    uint64_t m_lastIndex;
                } // fixedsizeheap.h
            }

            // c:\branches\discbot??\t1x-pc-?.?.?\shared\src\corelib\system
            namespace system {

                // c:\branches\discbot??\t1x-pc-?.?.?\shared\src\corelib\system\platform
                namespace platform {

                    struct ndsys {

                        struct Thread 0x10 {
                            void* m_nativeThread; // HANDLE*
                            uint32_t m_id;
                            uint32_t m_joinable;
                        } // thread.h

                        struct ThreadDesc 0x120 {
                            uint64_t m_stackSize;
                            uint32_t m_priority;
                            uint32_t m_affinity;
                            uint32_t m_flags;
                            char m_name[0x100];
                        }

                        struct Fiber 0x10 {
                            void* m_nativeFiber;
                            void* m_CtxBlock;
                        } // thread.h

                        struct FiberContext 0x280 {
                            // Fiber context data
                            char m_field0[0x40];
                            char m_field40[0x40];
                            char m_field80[0x40];
                            char m_fieldc0[0x40];
                            char m_field100[0x40];
                            char m_field140[0x40];
                            char m_field180[0x40];
                            char m_field1c0[0x40];
                            char m_field200[0x40];
                            char m_field240[0x40];
                        } // thread.h

                        struct Mutex 0x40 {
                            enum Type : uint32_t {
                                MUTEX_RECURSIVE = 0x1
                            };

                            void* m_data;
                            uint32_t m_threadID;
                            uint32_t m_lockCount;
                            Type m_type;
                            bool m_initialized;
                        } // mutex.h

                        struct MutexDesc 0x24 {
                            ndsys.Mutex.Type m_type;
                            char m_name[0x20];
                        };

                        struct ConditionVariable 0x20 {
                            void* m_ConditionVar; // CONDITION_VARIABLE*
                            bool m_initialized;
                        } // condition-variable.h
                    };
                }
            }

            // c:\branches\discbot??\t1x-pc-?.?.?\shared\src\corelib\job
            namespace job {

                enum JlsContext : uint32_t {
                    jobId = 0x0,
                    workerThreadIndex = 0x1,
                    renderFrameParams = 0x2,
                    CurrentAllocator = 0x3,
                    ScriptStackFrame = 0x6,
                    ScriptCFuncContext = 0x12,
                    ContextProcess = 0xc,
                    ContextPlayer = 0xe
                };

                // 16 bytes
                struct JlsEntry 0x10 {
                    StringId64 m_contextid;
                    uint64_t m_payload;
                };

                // 0x20 × 16 B = 512 B
                struct JlsBlock {
	                JlsEntry slots[0x20];
                };

                struct WorkerThreadDesc 0x200 {

                    struct Config 0x30 {
                       uint64_t m_workerPriority @ 0x8;
                    }

                    void* m_listHead;
                    void* m_listTail;
                    void* m_next;
                    void* m_prev;
                    void* m_waitNext;
                    void* m_waitPrev;
                    void* m_tlsBlock;
                    uint32_t m_flags;
                    uint64_t m_context @ 0x78;
                    Config m_config;
                    uint8_t m_scheduler[0x80] @ 0xb8;
                    void* m_nativeHandle;
                    uint32_t m_threadId;
                    uint32_t m_joinable;
                    void* m_threadTLS;
                    uint64_t m_waitCookie;
                    uint8_t m_shuttingDown;
                };
                
                struct WorkerInitContext 0x420 {
                    regenny.shared.corelib.system.platform.ndsys.Thread m_Thread @ 0x30;
                    WorkerThreadDesc m_WorkerThreadDesc @ 0x80;
                    regenny.shared.corelib.system.platform.ndsys.Fiber* m_fiber;
                    regenny.shared.corelib.system.platform.ndsys.ThreadDesc m_ThreadDesc;
                    char m_longName[0x20] @ 0x400 [[utf8*]];
                };

                struct JobHeap 0x98 {
                    corelib.containers.FixedSizeHeap m_Heap;
                    uint64_t m_field88 @ 0x88;
                    uint32_t m_field90;
                    uint32_t m_field94;
                };

                struct JobSystem 0x10 {
                    bool m_EnableStackChecking @ 0x8;
                    bool m_field9;
                    bool m_PrintJobSysDataStats;
                    bool m_EnableValidation;
                    bool m_EnablePerfCounters;
                    bool m_EnableDeadlockDetection @ 0xe;
                }; // s_JobSystem

                struct ndjob {

                    enum Priority : uint32_t {
                        KInvalid = 0xff,
                        KHigh = 0x1,
                        KNormal = 0x2,
                        KLow = 0x3
                    };

                    enum JobFlag : uint32_t {
                        None = 0x00,
                        // Allows for larger stack sizes.
                        LargeStack = 0x01,
                        // Marks job as part of the per-frame pipeline (logic/update side).
                        GameFramePhase = 0x04,
                        // Marks job as part of the render-frame pipeline (graphics side).
                        RenderFramePhase = 0x08,
                        // Writes a per-worker mask to [slot+0x80].
                        PinToCurrentWorker = 0x20,
                        // Used on the FrameSpawner job (root/system spawner).
                        FrameSpawner = 0x40,
                        // Skip perf timestamping at start/end.
                        SkipTiming = 0x80
                    };

                    enum CounterWakePolicy : uint32_t {
                        WakeOnEveryDecrement = 0x0,
                        WakeOnlyAtZero = 0x1, 
                    };

                    struct InitParams 0x78 {
                        void* m_pMemoryBuffer;
                        uint64_t m_memoryBufferSize;
                        void* m_pDebugMemoryBuffer;
                        uint64_t m_DebugMemoryBufferSize;
                        uint64_t m_numCounters;
                        uint64_t m_numJobArrays;
                        uint64_t m_numWorkerThreads;
                        void* m_field38;
                        uint16_t m_flags;
                        uint64_t m_field48 @ 0x48;
                        uint64_t m_maxSmallJobFibers;
                        uint64_t m_maxLargeJobFibers;
                        uint64_t m_smallJobFiberStackSpace;
                        uint64_t m_largeJobFiberStackSpace;
                        bool m_field70;
                    };

                    struct CounterHandle 0x40 {
                        char* m_file [[utf8*]];
                        uint32_t m_line;
                        char* m_function  @ 0x10 [[utf8*]];
                        uint64_t m_timestampQPC;
                        void* m_waitListHead;
                        uint64_t m_field28;
                        uint32_t m_CountJobArrays @ 0x30;
                        CounterWakePolicy m_wakeFlags @ 0x38;
                    };

                    struct JobHeader 0x80 {
                        void* m_entry; // Entry function
                        void* m_WorkData; // User data
                        CounterHandle* m_Counter;
                        CounterHandle* m_queuePrev;
                        CounterHandle* m_waitNext;
                        void* m_tlsBlock @ 0x30;
                        uint32_t m_stateBits;
                        uint64_t m_flags @ 0x40;
                    };

                    struct JobArrayHeader 0x100 {
                        uint32_t m_completedCount;
                        uint32_t m_writeIndex;
                        uint32_t m_issuedCount;
                        uint32_t m_jobCapacity;
                        JobHeader* m_JobStorage; // array of JobHeader
                        CounterHandle* m_JobCounter;
                        uint64_t m_field20;
                        uint32_t m_field28;
                        uint64_t m_allowedWorkersMask + 0x4;
                        void* m_heapBlock;
                        uint8_t m_state;
                        Priority m_priority @ 0x44;
                        uint64_t m_QueryPerformance @ 0x50;
                        uint64_t m_WorkerThreadIndex;
                    };

                    struct SchedLane 0x4080 {
                        JobArrayHeader* m_slots[0x800];
                        uint64_t m_count;
                    };

                    // Notice: Be careful with the offsets in the Data structures,
                    // they too sensitive to changes
                    struct SysData 0xc0 {
                        bool m_Initialized;
                        char m_field1[0xbf];
                    };

                    struct CounterData : SysData 0x180 {
                        uint64_t m_fieldf8 + 0xf8;
                        CounterHandle* m_Counters;
                        uint32_t m_maxSlots;
                        uint32_t m_nextFree;
                        uint32_t m_initialized;
                        void* m_heapBlock + 0x2c;
                    };

                    struct JobArrayData : SysData 0x180 {
                        JobArrayHeader* m_JobArrays + 0x80;
                        uint32_t m_maxHeaders;
                        uint32_t m_topIndex;
                        uint32_t m_initialized;
                        void* m_heapBlock + 0x1c;
                    };

                    struct FiberData : SysData 0x100 {
                        regenny.shared.corelib.system.platform.ndsys.FiberContext* m_FiberCtx;
                        regenny.shared.corelib.system.platform.ndsys.Fiber* m_smallFiberPool;
                        regenny.shared.corelib.system.platform.ndsys.Fiber* m_largeFiberPool;
                    };

                    struct WaitData : SysData 0x80 {
                        void* m_field8 + 0x8;
                        uint32_t m_field10;
                        uint32_t m_flags;
                        bool m_Initialized;
                        JobArrayHeader** m_JobStorage + 0x7; // array of JobArrayHeader*
                        JobArrayHeader* m_WaitingJobs;
                        JobArrayHeader* m_field30;
                        uint64_t m_numWaitingJobs;
                    };

                    struct WakeUpData : SysData 0x20280 {
                        // Not analyzed in detail
                        char m_field0[0x20204];
                        char m_field20204[4];
                        char m_field20208[4];
                        char m_field2020c[4];
                        char m_field20210[0xc];
                        char m_field2021c[4];
                        char m_field20220[4];
                        char m_field20224[4];
                        char m_field20228[0x18];
                        char m_field20240[0x40];
                    };

                    struct SchedData : SysData 0x100 {
                        SchedLane* m_lanes;
                    };

                    struct JobSysData 0x26d00 {
                        InitParams m_initParams;
                        bool m_IsQuit;
                        uint32_t m_readyWorkerCount @ 0x80;
                        uint64_t m_field90 @ 0x90;
                        uint64_t m_field98;
                        uint64_t m_fielda0;
                        uint64_t m_fielda8;
                        bool m_IsPowerSaveMode;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_PowerSaveLocks[0x18] @ 0xe0;
                        regenny.shared.corelib.system.platform.ndsys.ConditionVariable m_cvFreeJob[0x18];
                        regenny.shared.corelib.system.platform.ndsys.Thread m_workerThreads[0x18];
                        uint64_t m_numWorkerThreads;
                        void* m_hWorkerReadyEvent;
                        uint64_t m_workerMaskLo;
                        uint64_t m_workerMaskHi;
                        WorkerThreadDesc m_workerInfo[0x18] @ 0xc00;
                        SysData m_SysStatsData @ 0x54c0;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_StatsDataLock @ 0x5580;  
                        CounterData m_CounterData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_CounterDataLock @ 0x5800;
                        JobArrayData m_JobArrayData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_JobArrayDataLock @ 0x5a80;
                        FiberData m_FiberData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_FiberDataLock @ 0x5c80;
                        WaitData m_WaitData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_WaitDataLock @ 0x5e00;
                        WakeUpData m_WakeUpData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_WakeUpDataLock @ 0x26180;
                        SchedData m_SchedData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_SchedDataLock[0x9] @ 0x26380;
                    };
                }
            }
        }

        // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib
        namespace ndlib {
    
            struct EngineComponents {
                enum Component : uint32_t {
                    NdGameInfo = 0x0,
                    NdFrameState = 0x1,
                    PhotoModeManager = 0x2,
                    FileSystem = 0x3,
                    PackageMgr = 0x4,
                    PrefetchMgr = 0x5,
                    LevelMgr = 0x6,
                    LevelStreamingMgr = 0x7,
                    NdMessageManager = 0x8,
                    PSNTelemetry = 0xA,
                    AudioManager = 0xB,
                    NdDialogManager = 0xE,
                    NavMeshMgr = 0xF,
                    musicManager = 0xd,
                    NpcManager = 0x10,
                    AnimMgr = 0x11,
                    FgDrawMgr = 0x12,
                    ProcessMgr = 0x13,
                    ScriptManager = 0x14,
                    AnimStreamManager = 0x15,
                    Gui2 = 0x17,
                    TextureMgrPub = 0x18,
                    ParticleDebug = 0x1D
                }; // engine-components.hpp
            }
        
            struct NdConfig {
                enum Config : uint32_t {
                    NetInfo = 0x0, // m_pNetInfo
                    DMENU = 0x1,
                    NdDevMenu = 0x2,
                    NameCache = 0x7, // m_pNameCache
                    BUILD_NUMBER = 0x1e,
                    GameTitle = 0x20,
                    Profiling = 0xd1,
                    IsGameConfigured = 0xd2
                }; // (nd-config.hpp)
            }
        
            struct NdGameInfo 0x45c0 {
                void* vftable;
                char* m_internalname @ 0x118 [[utf8*]];
                StringId64 m_gametitlehash @ 0x120;
                char m_SavePath[0x400] [[utf8*]];
                char m_SavePath_unk[0x400] [[utf8*]];
                char m_GamePath[0x400] [[utf8*]];
                char m_GamePath_unk[0x400] [[utf8*]];
                char m_NetUserPath[0x400] [[utf8*]];
                char m_NetPath[0x400] [[utf8*]];
                char m_GameDataPath[0x400] [[utf8*]];
                char m_GameDataPath_unk[0x400] [[utf8*]];
                char m_BinPath[0x400] [[utf8*]];
                char m_BinPath_unk[0x400] [[utf8*]];
                char m_BranchName[0x40] [[utf8*]];
                char m_SrcPath[0x400] [[utf8*]];
                char m_DbPath[0x400] [[utf8*]];
                char m_GamePath_unk2[0x400] [[utf8*]];
                char m_CfgPath[0x400] +0x402 [[utf8*]];
                char m_CfgFolderName[0x80] [[utf8*]];
                char m_CfgDefaultsPath[0x80] [[utf8*]];
                uint16_t Unk_3ef0 +0x85;
                bool m_AssetView [[bool*]];
                bool m_DevConfig [[bool*]];
                bool m_onDisc [[bool*]];
                bool m_onDiscUseManifest [[bool*]];
                bool Unk_3ef5 [[bool*]];
                bool Unk_3ef6 [[bool*]];
                bool Unk_3ef7 [[bool*]];
                bool Unk_3ef8 [[bool*]];
                bool Unk_3ef9 [[bool*]];
                bool Unk_3efa [[bool*]];
                bool Unk_3efb [[bool*]];
                bool Unk_3efc [[bool*]];
                bool Unk_3efd [[bool*]];
                bool Unk_3efe [[bool*]];
                bool Unk_3eff [[bool*]];
                bool Unk_3f00 [[bool*]];
                bool Unk_3f01 [[bool*]];
                bool Unk_3f02 [[bool*]];
                bool Unk_3f03 [[bool*]];
                bool Unk_3f04 [[bool*]];
                bool Unk_3f05 [[bool*]];
                bool Unk_3f06 [[bool*]];
                bool Unk_3f07 [[bool*]];
                bool Unk_3f08 [[bool*]];
                bool Unk_3f09 [[bool*]];
                bool Unk_3f0a [[bool*]];
                bool Unk_3f0b [[bool*]];
                uint32_t m_env;
                bool Unk_3f10 [[bool*]];
                bool Unk_3f11 [[bool*]];
                bool Unk_3f12 [[bool*]];
                bool Unk_3f13 [[bool*]];
                bool Unk_3f14 [[bool*]];
                bool Unk_3f15 [[bool*]];
                bool Unk_3f16 [[bool*]];
                bool Unk_3f17 [[bool*]];
                bool Unk_3f18 [[bool*]];
                bool Unk_3f19 [[bool*]];
                bool Unk_3f1a [[bool*]];
                bool Unk_3f1b [[bool*]];
                bool m_IsMultiplayer [[bool*]];
                bool Unk_3f1d [[bool*]];
                bool Unk_3f1e [[bool*]];
                bool Unk_3f1f [[bool*]];
                bool Unk_3f20 [[bool*]];
                bool Unk_3f21 [[bool*]];
                bool Unk_3f22 [[bool*]];
                bool Unk_3f23 [[bool*]];
                bool Unk_3f24 [[bool*]];
                bool Unk_3f25 [[bool*]];
                bool Unk_3f26 [[bool*]];
                bool Unk_3f27 [[bool*]];
                bool Unk_3f28 [[bool*]];
                bool Unk_3f29 [[bool*]];
                bool Unk_3f2a [[bool*]];
                bool Unk_3f2b [[bool*]];
                bool Unk_3f2c [[bool*]];
                bool Unk_3f2d [[bool*]];
                bool Unk_3f2e [[bool*]];
                bool m_DevMode [[bool*]];
                bool Unk_3f30 [[bool*]];
                bool Unk_3f31 [[bool*]];
                bool Unk_3f32 [[bool*]];
                bool Unk_3f33 [[bool*]];
                bool Unk_3f34 [[bool*]];
                bool Unk_3f35 [[bool*]];
                bool Unk_3f36 [[bool*]];
                bool Unk_3f37 [[bool*]];
                bool Unk_3f38 [[bool*]];
                bool Unk_3f39 [[bool*]];
                bool Unk_3f3a [[bool*]];
                bool Unk_3f3b [[bool*]];
                bool Unk_3f3c [[bool*]];
                bool m_DebugRendering [[bool*]];
                bool Unk_3f3e [[bool*]];
                bool Unk_3f3f [[bool*]]
                bool Unk_3f40 [[bool*]];
                bool Unk_3f41 [[bool*]];
                bool Unk_3f42 [[bool*]];
                bool Unk_3f43 [[bool*]];
                bool Unk_3f44 [[bool*]];
                bool Unk_3f45 [[bool*]];
                bool Unk_3f46 [[bool*]];
                bool Unk_3f47 [[bool*]];
                bool Unk_3f48 [[bool*]];
                bool Unk_3f49 [[bool*]];
                bool Unk_3f4a [[bool*]];
                bool Unk_3f4b [[bool*]];
                bool Unk_3f4c [[bool*]];
                bool Unk_3f4d [[bool*]];
                bool Unk_3f4e [[bool*]];
                bool Unk_3f4f [[bool*]];
                bool Unk_3f50 [[bool*]];
                bool Unk_3f51 [[bool*]];
                bool Unk_3f52 [[bool*]];
                bool Unk_3f53 [[bool*]];
                bool Unk_3f54 [[bool*]];
                bool Unk_3f55 [[bool*]];
                bool Unk_3f56 [[bool*]];
                bool Unk_3f57 [[bool*]];
                uint32_t Unk_3f58;
                bool Unk_3f5c [[bool*]];
                bool Unk_3f5d [[bool*]];
                bool Unk_3f5e [[bool*]];
                bool Unk_3f5f [[bool*]];
                uint32_t Unk_3f60;
                bool m_DisableFpsStat [[bool*]];
                bool Unk_3f65 [[bool*]];
                bool Unk_3f66 [[bool*]];
                bool Unk_3f67 [[bool*]];
                bool Unk_3f68 [[bool*]];
                bool Unk_3f69 [[bool*]];
                bool Unk_3f6a [[bool*]]
                bool Unk_3f6b [[bool*]]
                bool Unk_3f6c [[bool*]];
                bool Unk_3f6d [[bool*]];
                bool Unk_3f6e [[bool*]];
                bool Unk_3f6f [[bool*]];
                bool Unk_3f70 [[bool*]];
                bool Unk_3f71 [[bool*]];
                bool Unk_3f72 [[bool*]];
                bool m_showBuildInfo [[bool*]];
                bool Unk_3f74 [[bool*]];
                bool Unk_3f75 [[bool*]];
                bool Unk_3f76 [[bool*]];
                bool Unk_3f77 [[bool*]];
                bool Unk_3f78 [[bool*]];
                bool Unk_3f79 [[bool*]]
                bool Unk_3f7a [[bool*]]
                bool Unk_3f7b [[bool*]]
                bool Unk_3f7c [[bool*]];
                bool Unk_3f7d [[bool*]];
                bool Unk_3f7e [[bool*]];
                bool Unk_3f7f [[bool*]];
                bool Unk_3f80 [[bool*]];
                bool Unk_3f81 [[bool*]];
                bool Unk_3f82 [[bool*]];
                bool Unk_3f83 [[bool*]];
                bool Unk_3f84 [[bool*]];
                bool Unk_3f85 [[bool*]];
                bool Unk_3f86 [[bool*]];
                bool Unk_3f87 [[bool*]];
                bool Unk_3f88 [[bool*]];
                bool Unk_3f89 [[bool*]];
                bool Unk_3f8a [[bool*]];
                bool Unk_3f8b [[bool*]];
                bool Unk_3f8c [[bool*]];
                bool Unk_3f8d [[bool*]];
                bool Unk_3f8e [[bool*]];
                bool Unk_3f8f [[bool*]];
                bool Unk_3f90 [[bool*]];
                bool Unk_3f91 [[bool*]];
                bool Unk_3f92 [[bool*]]; // smoketest
                bool Unk_3f93 [[bool*]];
                bool Unk_3f94 [[bool*]];
                bool Unk_3f95 [[bool*]];
                bool Unk_3f96 [[bool*]];
                bool Unk_3f97 [[bool*]];
                bool Unk_3f98 [[bool*]];
                bool Unk_3f99 [[bool*]];
                bool Unk_3f9a [[bool*]];
                bool Unk_3f9b [[bool*]];
                bool Unk_3f9c [[bool*]];
                bool Unk_3f9d [[bool*]];
                bool Unk_3f9e [[bool*]];
                bool Unk_3f9f [[bool*]];
                uint32_t Unk_3fa0;
                bool Unk_3fa4 [[bool*]];
                bool Unk_3fa5 [[bool*]];
                bool Unk_3fa6 [[bool*]];
                bool Unk_3fa7 [[bool*]];
                bool Unk_3fa8 [[bool*]];
                bool Unk_3fa9 [[bool*]];
                bool Unk_3faa [[bool*]];
                bool Unk_3fab [[bool*]];
                bool Unk_3fac [[bool*]];
                bool Unk_3fad [[bool*]];
                bool Unk_3fae [[bool*]];
                bool Unk_3faf [[bool*]];
                bool Unk_3fb0 [[bool*]];
                bool Unk_3fb1 [[bool*]];
                bool Unk_3fb2 [[bool*]];
                bool Unk_3fb3 [[bool*]];
                bool Unk_3fb4 [[bool*]];
                bool Unk_3fb5 [[bool*]];
                bool Unk_3fb6 [[bool*]];
                bool Unk_3fb7 [[bool*]];
                bool Unk_3fb8 [[bool*]];
                bool Unk_3fb9 [[bool*]];
                bool Unk_3fba [[bool*]];
                bool Unk_3fbb [[bool*]];
                uint32_t Unk_3fbc;
                bool Unk_3fc0 [[bool*]];
                bool Unk_3fc1 [[bool*]];
                bool Unk_3fc2 [[bool*]];
                bool Unk_3fc3 [[bool*]];
                bool Unk_3fc4 [[bool*]];
                bool Unk_3fc5 [[bool*]];
                bool Unk_3fc6 [[bool*]];
                bool Unk_3fc7 [[bool*]];
                bool Unk_3fc8 [[bool*]];
                bool Unk_3fc9 [[bool*]];
                bool Unk_3fca [[bool*]];
                bool Unk_3fcb [[bool*]];
                bool Unk_3fcc [[bool*]];
                bool Unk_3fcd [[bool*]];
                bool Unk_3fce [[bool*]];
                bool Unk_3fcf [[bool*]];
                bool Unk_3fd0 [[bool*]];
                bool Unk_3fd1 [[bool*]];
                bool Unk_3fd2 [[bool*]];
                bool Unk_3fd3 [[bool*]];
                bool Unk_3fd4 [[bool*]];
                bool Unk_3fd5 [[bool*]];
                bool Unk_3fd6 [[bool*]];
                bool Unk_3fd7 [[bool*]];
                char m_DiscUser[0x20] +0x30 [[utf8*]];
                char m_StatsBuild[0x20] @ 0x407c [[utf8*]];
                StringId64 AudioStringId @ 0x4180;
                bool m_ShowStats @ 0x43af [[bool*]];
                char m_GameStudio[0x40] @ 0x4463 [[utf8*]];
            }
        
            struct NdFrameState 0x288a0 {

                struct NdKeyboardLayer 0x1A60 {
                    bool m_enabled;
                    bool m_DebugKeyboard;
                    uint64_t m_keysPressed[4] @ 0x8; // 0x008-0x027
                    uint64_t m_keyState[4]; // 0x028-0x047
                    uint64_t m_keyState2[4]; // 0x048-0x067
                    uint64_t m_keys[4]; // 0x068-0x087  (current down mask)
                    uint64_t m_keyState3[4]; // helper masks (auto-repeat, etc.)
                    uint64_t m_keyCodes[4];
                    uint8_t scratch[0x80]; // zeroed in ctor
                    uint64_t m_invalid[4];
                    float m_repeatDelay @ 0x168; // 0.5 s   (3F000000h)
                    float m_repeatRate; // 0.1 s   (3DCCCCCDh)
                    uint32_t m_maxKeyCode; // r8d in ctor
                    uint64_t m_firstRepeatT @ 0x178; // initialised to -0x4000…
                    uint64_t m_nextRepeatT;
                    uint64_t m_keyTime[0x100]; // per-key timestamps (256 × 8 B)
                    NdKeyboardLayer* ring[8] @0x9C8; // layer ring-buffer pointers
                    uint32_t layerIndex @ 0xD28; // [rcx+0xD28] = edx in ctor
                };

                void* vftable;
                uint32_t m_TargetFramerate @ 0x20;
                uint32_t m_MinimumFramerate @ 0x28;
                uint32_t m_speed;
                uint64_t m_gameFrameNumber @ 0x40;
                bool m_KeyboardDevMode @ 0x51a;
                NdKeyboardLayer m_IMEKeyboard @ 0x10290;
                NdKeyboardLayer m_kbdLayer1;
                NdKeyboardLayer m_kbdLayer2;
                NdKeyboardLayer m_GameKeyboard;
                NdKeyboardLayer m_kbdLayer4;
                NdKeyboardLayer m_kbdLayer5;
            }
        
            struct FrameParams 0x17580 {

                struct InitParams {
                    FrameParams* m_ringBase;
                    uint64_t m_poolSlice0;
                    uint64_t m_poolSlice1;
                    uint64_t m_poolSlice2;
                    uint64_t m_poolSlice3;
                    uint64_t m_poolSlice4;
                    uint64_t m_poolSlice5;
                }; // s_FrameParams

                uint64_t m_frameNumber;
                void* m_gfxEopTick @ 0x50;
                void* m_DynamicRenderContext @ 0x6a80;
                void* m_pRenderCamera @ 0x13758;
                void* m_pUploadQueue @ 0x14eb8;
            } // frame-params.cpp

            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib\settings
            namespace settings {
                
                struct SettingsControl 0x9a70 {

                    enum SettingFlags : uint8_t {
                        Active = 0x1,
                        Process = 0x2,
                        Timed = 0x4,
                        HasData = 0x8,
                        ExternalData = 0x10
                    };

                    struct Setting 0xa0 {
                        void* m_ProcessPtr; 
                        uint32_t m_ownerId; 
                        uint64_t m_expireFrame; 
                        uint32_t m_type; 
                        void* m_Callback @ 0x20;
                        void* m_valuePtr;
                        uint32_t m_bucketId;
                        uint32_t m_sequence;
                        uint8_t m_data[0x44] @ 0x40;
                        void* m_pData @ 0x88;
                        uint8_t m_cbByte;
                        SettingFlags m_flags;
                        StringId64 m_key @ 0x98;
                    };

                    struct HashNode 0x20 {
                        HashNode* m_pNext;
                        HashNode* m_pPrev;
                        Setting* m_pFirst;
                        Setting* m_pLast;
                    };

                    struct HashIt 0x10 {
                        HashNode** m_ppSlot;
                        HashNode* m_pNode;
                    };

                    struct SettingsHash 0x98 {
                        HashNode** m_table;
                        corelib.containers.FixedSizeHeap m_pool;
                        HashNode* m_head;
                        uint64_t m_elemSize;
                        uint64_t m_capacity;
                        HashNode** m_begin;
                        HashNode** m_end;
                        uint64_t m_count;
                        uint32_t m_roundedCap;
                        uint32_t m_flags;
                    };

                    uint64_t m_usedMask[0x4b][0x40];
                    void* m_poolBase;
                    void* m_bucketPtr[0x4b];
                    uint32_t m_bucketTag[0x4b];
                    uint32_t m_numUsedBuckets;
                    uint32_t m_maxNumSettings;
                    HashNode** m_settingHashTable @ 0x99a0;
                    corelib.containers.FixedSizeHeap m_hashNodePool;
                    HashNode* m_hashListHead;
                    uint64_t m_hashElemSize;
                    uint64_t m_hashCapacity;
                    HashNode** m_hashBegin;
                    HashNode** m_hashEnd;
                    uint64_t m_hashCount;
                    uint32_t m_hashRoundedCap;
                    uint32_t m_hashMaxAndFlags;
                    uint8_t m_rtFlag;
                    uint32_t m_rtCounter @ 0x9a3c;
                    uint32_t m_nextSequence;
                    uint8_t m_waitListLock[0x20] @ 0x9a50;
                }; // settings.cpp
            }
        
            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib\debug
            namespace debug {

            struct DMENU 0x670 {

                enum Message : uint32_t
                {
                    OnOpen = 0x0,
                    OnClose = 0x1,
                    OnUpdate = 0x3,
                    OnExecute = 0x5,
                    OnReadConfig = 0x7,
                    OnSaveConfig = 0x8,
                    OnFocusOut = 0x10
                };

                // DMENU::Component (class_DMENU::Component_vfTable)
                struct Component 0xb0 {
                    struct VTable 0xb0 {}
                    void* vftable;
                    void* UnkString;
                    char m_name[0x20] [[utf8*]] // (Only if string length is less than 32 characters)
                    char* m_pname [[utf8*]];
                    Component* m_ParentComponent;
                    Component* m_NextDMenuComponent;
                    uint32_t m_MenuLeftPad;
                    uint32_t m_MenuWidth;
                    uint64_t m_ItemLeftPad;
                    uint64_t Unk2;
                    uint64_t m_data; // For arguments or link variable
                    uint32_t m_color;
                    uint32_t m_selectcolor;
                    uint32_t m_editedcolor; // maybe
                    bool m_Islinked; // BY KEY ID
                    void* m_lazyinitcallback @ 0x78;
                    char* m_pDescription [[utf8*]];
                    bool m_atsign;
                    Component* m_MenuGroup + 0x7;
                    bool m_isfavorite + 0x1;
                    int m_PagePointer + 0x6; // Only with menu component?
                    int m_MaxPagePointers;
                    uint64_t m_ExtraArg;
                } 

                // DMENU::Menu | DMENU::ItemSubmenu
                struct Menu : Component 0x30 {
                    Component* m_Item;
                    bool m_isActive + 0x4;
                    uint64_t m_pad : 2;
                    int m_MaxDisplayItems +0x7;
                    uint64_t Unk[0x2];
                } // 0x14041ec20

                // DMENU::MenuGroup
                struct MenuGroup : Component 0x280 {
                    Menu* m_RootMenu;
                    bool m_IsDisplayed + 0x8;
                    bool m_Rendering;
                    uint16_t Unk[0x3];
                    uint64_t Unk2[0x4d];
                } // 0x14041eca0

                // DMENU::KeyBoard*
                struct KeyBoard : Component 0x830 {
                    bool m_isEditing;
                    bool m_needsUpdate;
                    bool m_isDirty;
                    bool m_isFrameActive;
                    uint32_t m_cursorIndex @ 0xb8;
                    uint32_t m_lastKey;
                    char m_inputBuffer[0x400] @ 0xd0 [[utf8*]]
                    char m_displayBuffer[0x400] [[utf8*]]
                    char* m_inputBufferPtr [[utf8*]];
                    uint64_t m_maxInputLength;
                }

                // DMENU::Item (class_Dmenu::Item_vfTable)
                struct Item : Component 0x8  {
                    struct VTable : DMENU.Component.VTable 0x48 {}
                    void* m_callbackFunct;
                } // 0x14041e6b0

                // DMENU::ItemSubmenu
                struct ItemSubmenu : Item 0x10  {
                    Menu* m_pHeader; // Entry Pointer
                    uint64_t Unk[0x1];
                } // 0x14041ea90

                // DMENU::ItemBool
                // Component.m_data - ValuePtr
                struct ItemBool : Item 0x8  {
                   bool m_status;
                   bool m_pad[0x7];
                } // 0x14041cd70

                // DMENU::ItemDecimal* 
                // Component.m_data - ValuePtr
                struct ItemDecimal : Item 0xb8  {
                    uint64_t* m_format; // format Printf %d 
                    void* m_HandlerFunc; // handler slider function 
                    uint64_t m_DisplayValue [[i64]];
                    uint64_t UnkDouble [[i64]];
                    uint64_t m_MinValue [[i64]];
                    uint64_t m_MaxValue [[i64]];
                    uint64_t m_StepValue [[i64]];
                    uint64_t m_DoubleStepValue [[i64]];
                    uint64_t Unk2[0x7];
                    char m_StringDisplayValue[0x20] [[utf8*]];
                    uint64_t Unk3[0x4];
                } // 0x14041cd70

                // DMENU::ItemFloat* 
                // Component.m_data - ValuePtr
                struct ItemFloat : Item 0x98  {
                    uint64_t* m_format; // format Printf %6.2f
                    void* m_HandlerFunc; // handler slider function 
                    float m_DisplayValue;
                    float UnkFloat;
                    float m_MinValue;
                    float m_MaxValue;
                    float m_StepValue;
                    float m_DoubleStepValue;
                    uint64_t Unk2[0x6];
                    char m_StringDisplayValue[0x20] [[utf8*]];
                    uint64_t Unk3[0x4];
                } // 0x14041d960

                // DMENU::ItemFunction 
                struct ItemFunction : Item 0x10  {
                    void* unkData; // probably for link key->value
                    bool m_isActive @ 0xc1;
                    bool m_pad[0x6];
                } // 0x14041dad0

                 // DMENU::ItemSelection* 
                struct ItemSelection : Item 0x30  {
                    void* UnkData; // m_format probably
                    void* m_callbackFormat;
                    uint64_t Unk2[0x3];
                    void* m_SelectionStruct;
                } // 0x14041d610

                // DMENU::ItemSubText*
                struct ItemSubText : Item {} // 0x14041e6b0;

                // DMENU::String*
                struct String : Component {}

                // DMENU::ItemPlaceHolder
                struct ItemPlaceHolder : Component 0x400 {
                    char m_placeholder[0x400] [[utf8*]];
                } // 0x14041e880;

                // DMENU::ItemLine*
                struct ItemLine : Component {} // 0x14041d490;

                void* vftable;
                bool m_Text2DropShadows +0x8
                bool m_PauseDuringMenus
                bool m_PauseDuringMenusMP 
                bool m_Pauseonexit
                bool m_ShowPausedIndicator
                bool UnkBool;
                bool m_SquareButtontoBackOutofMenus
                bool m_ChordtoSave
                bool m_AlignMenusRight
                int  m_Rightmargin @0x1c
                float m_MenuAlpha [[f32]]
                float m_MenuScale [[f32]]
                bool m_Pause @0x61
                MenuGroup* m_CurrentMenu +0xe [[u64]]
                MenuGroup* m_QuickMenu
                MenuGroup* m_DevMenu [[u64]]
                MenuGroup* m_FavoritesMenu [[u64]]
                uint64_t Unk2[0xbc];
            }  
            }
    
            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib\process
            namespace process {
            struct process 0x100 {}
            }
    
            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib\render
            namespace render {

            enum WindowContextType : uint32_t
            {
                Context0 = 0x0,
                Context1 = 0x1,
                Context2 = 0x2,
                Context3 = 0x3,
                Context4 = 0x4,
                Context5 = 0x5,
                Context6 = 0x6,
                Context7 = 0x7,
                Context8 = 0x8
            };

            struct WindowContext 0x30 {
                WindowContextType m_ContextType;
                void* FrameParams;
                uint64_t field_10;
                uint64_t field_18;
                uint64_t field_20;
                uint64_t field_28;
            }


            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib\render\text
            namespace text {
                struct DebugStringBase 0x48 {
                    void* vftable;
                    uint64_t unk08;
                    vec4 vec;
                    uint32_t color;
                    float scale;
                    uint8_t fade;
                    uint64_t reserved @ 0x2c;
                    uint32_t field_34;
                    uint64_t field_38;
                    char* pText  @ 0x40 [[utf8*]];
                }
            }

            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib\render\util
            namespace util {

                struct PrimServer 0x1380 {

                    struct VTable 0x318 {
                        virtual void Render(ndlib.render.WindowContext* WindowContext) @ 1
                        virtual void Render2D(ndlib.render.WindowContext* WindowContext) @ 2
                        virtual void Render3D(ndlib.render.WindowContext* WindowContext) @ 3
                        // virtual void RenderLine(_, _, _) @ 20
                        virtual uint64_t RenderString(text.DebugStringBase* header, void* DebugPrimParams, void* BoundFrame) @ 25
                        virtual void InitFrameParams(ndlib.FrameParams* RenderFrameParams) @ 55
                        virtual void ClearAll() @ 56
                        virtual void ReleaseMem() @ 57
                        virtual void ReleaseFrameHeap() @ 58
                        virtual void SetPaused(bool arg2, bool arg3, int arg4) @ 59
                        virtual void CullStale() @ 60
                    } 

                    struct InitParams 0x4c {
                        uint32_t m_memoryBufferSize[0x13];
                    }

                    VTable* vftable;
                }

            }
            }

            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib\profiling
            namespace profiling {
                struct ProfileCtrl 0x70 {};
                struct ProfileMgr 0x1e50 {
                    uint64_t m_numWorkerThreads @ 0x420;
                    corelib.containers.FixedSizeHeap m_FixedSizeHeap @ 0x1db8;
                }; // s_ProfileMgr
            }
    
            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib\util
            namespace util {
                struct BitReader 0x18 {
                    uint64_t m_FixUpTable;
                    uint32_t m_bitIndex;
                    uint32_t m_byteIndex;
                    uint32_t m_size;
                    uint32_t field_14;
                }; // bit-reader.h
            }
    
    
            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib\script
            namespace script {
            
                // #lang dc
                namespace DC {
    
                 /* 
                DC::ScriptId:
                    modules = 0x0B4B7080C994E5B8, // *modules*
                    persistent_command_list = 0x0D4214F3AB9F95C3, // *persistent-command-list*
                    mouse_default_settings = 0x153A061C977AB3B4, // *mouse-default-settings*
                    analog_stick_icon_paths = 0x6ECB9D5F76F9A2E7, // *analog-stick-icon-paths*
                    melee_override_ids = 0x7E555F8321D35D11, // *melee-override-ids*
                    weapon_cross_press_release_blacklist = 0xB8A76AAD46BA03C6, // *weapon-cross-press-release-blacklist*
                    joypad_additional_presets = 0xF1F762C8F706097D, // *joypad-additional-presets*
                    action_map = 0x939AA361BA96F916, // *action-map*
                */
    
                /* 
                DC::TYPE:
                    Array = 0x4F9E14B634C6B026, // @ Array
                    _array = 0x104D3D9BAD9D2464, // @ array*
                    map = 0x080F5919176D2D91, // @ map
                    _float = 0xA00A62A942B20165, // @ float
                    symbol_array = 0xC8F749F92779D489, // @ symbol-array
                    module_info_array = 0xE442DCB00300FB28, // @ module-info-array
                    action_scheme = 0x9FF30B9A5C83CB5D, // @ action-scheme
                    command_list = 0xB18C294ADE7B782B, // @ B18C294ADE7B782B
                    mouse_settings = 0xD6BCF8E23269E80E, // @ D6BCF8E23269E80E
                    input_scheme = 0xAF5C458ED236456E, // @ AF5C458ED236456E
                */
    
                    struct Entry 0x18 {
                        StringId64 m_scriptId;
                        StringId64 m_typeId;
                        void* m_entryPtr;
                    };   
                
                    struct Header 0x20 {
                        uint32_t m_magic;
                        uint32_t m_versionNumber;
                        uint32_t m_textSize;
                        uint32_t unk;
                        uint32_t unk1;
                        uint32_t m_numEntries;
                        Entry* m_pStartOfData;
                    };
                
                    // @ map
                    struct map {
                        uint64_t m_size;
                    };
    
                    // @ modules.bin
                    namespace modules {
                    
                        /*
                           @ file: modules.bin
                           @ ScriptId: *modules*
                           @ TYPE: module-info-array
                           @ EntryPtr: ModuleInfoArray
                        */ 
                        struct modules {
                        
                            // @ symbol-array
                            struct ModuleUnkCollection 0x10 {
                                uint64_t m_num;
                                StringId64* m_pArray; // @ Array
                            };
                        
                            // @ symbol-array
                            struct ModuleCollection 0x10 {
                                uint64_t m_num;
                                StringId64* m_modules; // @ Array
                            }   
                            // @ Array
                            struct ModuleInfo 0x28 {
                                char* m_name [[utf8*]];
                                StringId64 m_hash;
                                uint64_t m_size;
                                ModuleCollection* m_pCollection;
                                ModuleUnkCollection* m_unkCollection;
                            }   
                            // @ module-info-array
                            struct ModuleInfoArray 0x10 {
                                uint64_t m_numModules;
                                ModuleInfo* m_modules;
                            };   
                        }
                    }
    
                    // @ joypad.bin
                    namespace joypad {
                    
                        /*
                            @ ScriptIds: *joypad-???*
                            @ TYPE: action-scheme
                            @ EntryPtr: ActionScheme 
                        */
                        struct actionscheme { 
                        
                            // @ Array
                            struct inputKeyboard 0x10 {
                                uint64_t m_flag;
                                uint64_t m_keycode;
                            };
                        
                            // @ Array
                            struct inputJoypad 0x10 {
                                uint64_t m_flag;
                                uint64_t m_iBtn;
                            };
                        
                            // @ Array
                            struct inputMouse 0x18 {
                                uint64_t m_flag;
                                uint64_t m_keycode;
                                uint64_t m_keycode2;
                            };
                        
                            // @ Array
                            struct Input 0x10 {
                                uint64_t m_flag;
                                StringId64 m_hash;
                            };
                        
                            // @ symbol-array
                            struct InputCollection 0x10 {
                                uint64_t m_numInputs;
                                StringId64* m_pArray;
                            };   
                        
                            // @ #793D1D63A0498239
                            struct inputKeyboardScheme 0x10 {
                                uint64_t m_count;
                                inputKeyboard* m_scheme;
                            };
                        
                            // @ #674A8555C679C8ED
                            struct inputJoypadScheme 0x10 {
                                uint64_t m_count;
                                inputJoypad* m_scheme;
                            };
                        
                            // @ #66D642190729CBE3
                            struct inputMouseScheme 0x10 {
                                uint64_t m_count; // always 2?
                                inputMouse* m_scheme;
                            };
                        
                            // @ #5688596AABA88521
                            struct inputScheme 0x10 {
                                uint64_t m_count;
                                Input* m_scheme;
                            };
                        
                            // @ #FD17AE86396612F7
                            struct inputCommand 0x90 {            
                                inputJoypadScheme* m_Joypadinputs;
                                inputKeyboardScheme* m_Keyboardinputs;
                                inputKeyboardScheme* inputKeyboardButtons; // always nullptr in raw module
                                inputMouseScheme* m_Mouseinputs;
                                inputMouseScheme* inputMouseButtons; // always nullptr in raw module
                                bool field_28;
                                inputScheme* m_inputs @ 0x30; // Common for inputKeyboardButtons & inputMouseButtons & m_inputButtons?
                                inputJoypadScheme* m_inputButtons; // always nullptr in raw module
                                uint32_t field_40;
                                uint32_t field_44;
                                uint64_t field_48; // always 000000003DCCCCCD?
                                StringId64 m_InputHash; // Example: *gesture-tap-left-stick-up-wide* (Manually allocated in the game)
                                uint64_t field_58;
                                InputCollection*  m_InputCollection; // i guess 
                                uint64_t field_68;
                                bool field_70; // something for field_68
                                bool field_80 @ 0x80;
                                bool field_81; // inputs allocated??
                                char* field_88 @ 0x88 [[utf8*]];
                            };
                        
                            // @ action-scheme
                            struct ActionScheme 0x10 {
                                struct Scheme : map {
                                    StringId64* m_key;
                                    inputCommand* m_value;
                                }
                            
                                Scheme *m_scheme @ 0x8;
                            };   
                        }
                    
                        /*
                            @ ScriptId: *persistent-command-list*
                            @ TYPE: #B18C294ADE7B782B
                            @ EntryPtr: CommandList 
                        */
                        struct CommandList 0x10 {
                           uint64_t m_size;
                           StringId64* m_commands;
                        };
                    
                         /*
                            @ ScriptId: *mouse-default-settings*
                            @ TYPE: #D6BCF8E23269E80E
                            @ EntryPtr: MouseSettings 
                        */
                        struct MouseSettings 0x40 {
                            uint32_t global_sensitivity;
                            uint32_t aim_sensitivity_x;
                            uint32_t aim_sensitivity_y;
                            uint32_t look_sensitivity_x;
                            uint32_t look_sensitivity_y;
                            uint32_t snipe_sensitivity_x;
                            uint32_t snipe_sensitivity_y;
                            uint32_t acceleration_x;
                            uint32_t acceleration_y;
                            bool invert_x;
                            bool invert_y;
                            bool field_26;
                            bool use_raw_input;
                        };
                    
                        /*
                            @ ScriptId: *analog-stick-icon-paths*
                            @ TYPE: Array
                            @ EntryPtr: AnalogStickIconPath
                        */
                        struct AnalogStickIconPath 0x18 {
                            char* m_Path [[utf8*]];
                            char* m_Path2 [[utf8*]];
                            StringId64 m_hash;
                        };
                    
                        /*
                            @ ScriptId: *analog-stick-icon-paths*
                            @ TYPE: Array
                            @ EntryPtr: AnalogStickIconPath
                        */
                        struct actionmap {
                        
                             // @ Array
                            struct ActionDefinition 0x18 {
                                uint64_t field_0;
                                uint64_t field_8;
                                uint64_t field_10;
                            };
                        
                            // @ #11AE032C43498287
                            struct kActionDefinition 0x10 {
                                uint64_t m_size;
                                ActionDefinition* field_8;
                            };
                        
                            // @ #78A4C32D131A03BD
                            struct InputDefinition 0x40 {
                                uint64_t field_0;
                                uint64_t field_8;
                                uint64_t field_10;
                                uint64_t field_18;
                                StringId64 field_20;
                                StringId64 field_28;
                                uint64_t field_30;
                                StringId64 field_38;
                            };
                        
                            // @ #AF5C458ED236456E
                            struct ActionSet 0x18 {
                            
                                struct InputDefScheme : map {
                                    StringId64* m_key;
                                    InputDefinition* m_value;
                                }
                            
                                InputDefScheme* m_InputDef;
                                StringId64* field_8;
                                kActionDefinition* field_10;
                            };   
                        };
                    
                         /*
                            @ ScriptId: *joypad-additional-presets*
                            @ TYPE: array*
                            @ EntryPtr: FixedSizeArray<Array<AdditionalPresets>>
                        */
                        struct presets {

                            // @ #??????????????????
                            struct Preset 0x20 { 
                                StringId64 field_0;
                                uint64_t field_8;
                                uint32_t field_10;
                                uint32_t field_14;
                                uint16_t field_18;
                                uint32_t field_1a;
                            };
                        
                            // @ #6043A6D761AA41FF
                            struct AdditionalPresets 0x38 {
                                uint64_t field_0;
                                StringId64 field_8;
                                StringId64 field_10;
                                uint64_t field_18;
                                Preset* m_presets;
                                uint32_t m_count;
                                uint64_t field_30;
                            };
                        };
                    }
                }
            
                struct ScriptValue {
                    uint64_t val[0x10];
                };

                struct ScriptCFunc 0x10 {
                    struct VTable 0x8 {
                        virtual void CallScriptCFunc(gamelib.state_script.ScriptCFuncContext* CFuncContext, uint32_t ArgsNum, ScriptValue* return_, uint64_t arg4) @ 0;
                    };  

                    VTable* vftable;
                    void* m_pFunction;
                };
            
                // script-module-loader.cpp
                // List<ModuleRequest>
                struct ModuleRequest 0x40 {
                
                    struct ModuleRequestList 0x10 {
                        ModuleRequest* m_head;
                        ModuleRequest* m_tail;
                    }
                
                    ModuleRequest* m_NextModuleRequest;
                    ModuleRequest* m_PrevModuleRequest;
                    StringId64 m_hash;
                    uint64_t m_field18;
                    regenny.shared.corelib.memory.Context m_MemContext;
                    uint32_t m_index;
                    size_t m_size;
                    uint64_t m_field30;
                    bool m_field38; // DEBUG AssetView?
                    bool m_field39;
                    bool m_field3a;
                    bool m_field3b;
                    bool m_field3c;
                    bool m_requested;
                }
            
                // ScriptManager::ModuleInfo::Constructor (0x141e71328)
                struct ModuleInfo 0x60 {
                     ModuleInfo* m_NextModule;
                     ModuleInfo* m_PrevModule;
                     char* m_name [[utf8*]];
                     StringId64 m_hash;
                     size_t m_size;
                     uint64_t m_pCollection;
                     uint32_t m_pNumModules;
                     uint64_t m_pUnkCollection @ 0x38;
                     uint32_t m_pNumEntries;
                     ScriptModule* m_ScriptModule @ 0x48;
                     uint64_t m_field50;
                     uint32_t m_field58;
                     bool m_field5c;
                     bool m_IsLocal;
                     bool m_DebugModule;
                     bool m_isLoaded;
                }

                struct PointerBase 0x28 {
                    void* m_ptr; // DC::Entry.m_entryPtr
                    ModuleInfo* m_module;
                    StringId64 m_symbolId;
                    StringId64 m_moduleId;
                    uint32_t m_field20;
                    bool m_resolveAttempted;
                };

                struct relocatableModule 0x30 {
                    void* vfTable;
                    uint64_t m_pRecord;
                    uint64_t m_field10;
                    uint64_t m_field18;
                    char* m_ModuleInfoArray [[utf8*]];
                    char* m_ModuleInfoArrayDebug [[utf8*]];
                };
            
                struct ScriptModule 0x78 {
                    struct Loader 0x4e0 {
                        ModuleInfo* m_moduleinfo @ 0x440;
                        uint64_t m_moduleName;
                        corelib.memory.Context m_moduleMemContext;
                        void* Data @ 0x480;
                        ScriptModule* m_Module @ 0x4c0;
                        uint64_t m_field4c8;
                        bool m_field4d0;
                        bool m_field4d1;
                        bool m_field4d2;
                        uint16_t m_field4d3;
                        bool m_field4d5;
                        bool m_field4d6;
                    };

                    void* vfTable;
                    ScriptModule* m_NextModule;
                    ScriptModule* m_PrevModule;
                    uint64_t m_field18;
                    char* m_ModuleName [[utf8*]];
                    StringId64 m_modulehash;
                    StringId64 m_field30;
                    uint32_t m_numEntries;
                    DC.Entry* m_Data @ 0x40;
                    ModuleInfo* m_ModuleInfo;
                    DC.Header* m_header;
                    uint64_t m_loadtime;
                    corelib.memory.Context m_moduleMemContext;
                    uint32_t m_field64;
                    uint32_t m_field68;
                    uint32_t m_size;
                    uint32_t m_LockCount;
                };


                struct ModuleBucket 0x98 {
                    uint64_t m_data;
                    corelib.containers.FixedSizeHeap m_heap;
                    uint64_t m_data2;
                    uint32_t m_elementSize;
                    uint64_t m_capacity;
                    uint64_t m_data3;
                    uint64_t m_field80;
                    uint64_t m_field88;
                    uint32_t m_field90;
                    uint32_t m_flags;
                };

                struct ModuleBucketMap 0x1f0 {
                    corelib.containers.FixedSizeHeap m_SymbolsHeap @ 0x8;
                    uint64_t* field_60;
                    uint64_t field_68;
                    uint64_t m_maxGlobalSymbols;
                    void* m_SymbolsHead;
                    void* m_SymbolsTail;
                    uint64_t m_numGlobalSymbols;
                    uint64_t* m_symbolBuckets;
                    ModuleInfo* m_ModulesHead;
                    ModuleInfo* m_ModulesTail;
                    ModuleBucket* m_ModuleBucket;
                    corelib.containers.FixedSizeHeap m_ModulesHeap;
                    uint64_t m_maxModules @ 0x118;
                    uint64_t m_numModules @ 0x130;
                    uint64_t m_ScriptModuleCapacity @ 0x140;
                    ScriptModule* m_ScriptModulesHead;
                    ScriptModule* m_ScriptModulesTail;
                    ModuleBucket* m_ScriptModuleBucket;
                    corelib.containers.FixedSizeHeap m_ScriptModuleHeap;
                    uint64_t m_maxScriptModules @ 0x1c8;
                    uint64_t m_numScriptModules @ 0x1e0;
                    uint32_t m_bucketCount;
                    uint32_t m_lookupFlags;
                }
            
                // script-manager.cpp
                struct ScriptManagerGlobals 0x33b0 {

                    struct ScriptCFuncMap 0x10 {
                        void* m_FunctionsBaseAddress;
                        uint64_t m_FunctionsNum;
                    }

                    uint64_t field_0;
                    StringId64 m_JlsContext @ 0x10; // ScriptManagerGlobals
                    corelib.job.JlsContext m_JlsIndex;
                    uint64_t field_20 @ 0x20;
                    uint64_t field_30 @ 0x30;
                    bool m_EnableScriptTrace @ 0x40;
                    bool m_Autoreloadbinfiles @ 0x42;
                    bool m_DisplayRequestedModules;
                    bool m_DumploadlisttoTTY;
                    bool m_Showoverflowedmodules;
                    bool m_ShowScriptErrors;
                    bool m_PrintmodulesCon;
                    bool m_PrintmodulescountsCon;
                    bool m_ShowDebugBinStatusCon;
                    bool m_DumpStateScriptsonStackFrameHighWater @ 0x4c;
                    bool m_EnableScriptModuleCRC32Checks;
                    bool m_field4e;
                    bool m_ValidateModuleSize;
                    bool m_AssertonGlobalSymbolLookup;
                    bool m_EnableScripts;
                    bool m_field52;
                    bool m_field53;
                    bool m_DisableScriptDebugPrims;
                    bool m_DisplayGlobalSymbols;
                    bool m_ModuleIndexInit;
                    bool m_DisableDebugBinSuppressionforGameTasks;
                    bool m_field58;
                    bool m_field5a @ 0x5a;
                    bool m_DisableDebugBins;
                    bool m_field5c;
                    char m_field5e @ 0x5e;
                    uint32_t m_field60 @ 0x60;
                    uint64_t m_field68 @ 0x68;
                    ModuleRequest.ModuleRequestList* m_moduleRequestListActual;
                    ModuleBucketMap m_ModulesBucket;
                    ScriptCFuncMap* m_NativeMap @ 0x298;
                    ScriptModule.Loader* s_SLoadM;
                    uint64_t m_field2e80 @ 0x2e80;
                    uint64_t m_field3338 @ 0x3338;
                    bool m_field3340;
                    bool m_moduleLoader @ 0x336b;
                    bool m_field336c;
                    bool m_field336d;
                    bool m_field3371 @ 0x3371;
                    uint32_t m_field3380 @ 0x3380;
                    uint64_t m_field3388 @ 0x3388;
                    uint64_t m_field3390;
                    uint64_t m_field3398;
                    uint32_t m_field33a0;
                    uint64_t m_field33a8 @ 0x33a8;
                }; // g_scriptGlobals

            }
    
        // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\ndlib\io
        namespace io {

            // not verified for t1x
            struct FileSystem {

                // usage SCE FIOS legacy...
                struct ArchiveMount 0x18 {

                    enum ArchiveMountFlags : uint32_t {
                        Patch = 0x1,
                        Dynamic = 0x2,
                        Opaque = 0x4
                    };

                    uint32_t m_fh;
                    ArchiveMountFlags m_flags;
                    void* m_pMountBuffer; // FIOS DATA (Not Resolved)
                    uint64_t m_sizeBytes;
                };

            };

            struct PackageMgr {}; // not verified for t1x

            struct PrefetchMgr 0x9e0 {

                struct PrefetchEntry {
                    uint8_t m_Flags;
                    uint8_t m_DirSlot;
                    uint16_t m_field02;
                    uint32_t m_field04; 
                    char* m_FileName [[utf8*]];
                };

                void* m_EntryTable;
                void* m_EntryAux;
                uint64_t m_PendingBits[0x5e];
                uint32_t m_field300;
                uint32_t m_MaxEntries;
                FileSystem* m_FileSystem;
                PackageMgr* m_PackageMgr;
                char m_GameDataPath[0x400] @ 0x31c [[utf8*]];
                uint32_t m_GameDataPathLen;
                bool m_UseGameDataPrefix;
                bool m_Paused;
                uint32_t m_QueueHead @ 0x750;
                uint32_t m_field754;
                uint32_t m_FileNamePoolHead;
                uint32_t m_DirSlotCount;
                void* m_DirTable;
                void* m_FileNamePool;
                uint32_t m_FileNamePoolCapacity;
                uint32_t m_FileNameHighWater;
                uint32_t m_FileNameUsed;
                corelib.system.platform.ndsys.Thread m_Threads[0x1f] @ 0x780;
                corelib.system.platform.ndsys.Mutex m_PrefetchAccessLock;
                corelib.system.platform.ndsys.ConditionVariable m_PrefetchCondVar;
                bool m_ShutdownRequested;
            }; // prefetch.cpp
        }
    
        }

        // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\gamelib
        namespace gamelib {

            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\gamelib\level
            namespace level {

                struct GameLoading {

                    enum TransitionStatus : uint32_t {
                        // Idle / finished:
                        kSteady = 0x00, // WaitForSteadyState() waits for this

                        // Early pipeline stages scheduled by UpdateInternal():
                        kMountWorld = 0x01, // schedules GameLoadingMountWorld
                        kMountLanguage = 0x02, // schedules GameLoadingMountLanguage
                        kMountSPMP = 0x03, // schedules GameLoadingMountSPMP
                        kCopyToHDD = 0x04, // schedules GameLoadingCopyToHDD
                        kPlayGoWait = 0x05, // schedules GameLoadingPlayGoWait
                        kPlayGoWait_Alias = 0x06, // alias into PlayGo wait path (same dispatch)

                        // Set once the initial-archives job finishes its countdown:
                        kMountedInitial = 0x07,
                        // Initial-archives countdown sequence stages:
                        kMountingOthers = 0x08, // WaitForFirstWorldAvailability()
                        kMountingFirstWorld = 0x09, // ...
                        kMountingSPCommon = 0x0A, // ...
                        kMountingMPCommon = 0x0B, // ...
                        kMountingCommon = 0x0C, // WaitForCommonAvailability()
                        kMountingCore = 0x0D, // WaitForCoreAvailability()
                        kMountingBin = 0x0E, // ...
                    };

                    enum SpMpMode : uint32_t {
                        kModeNone = 0x0, 
                        kModeSP = 0x1, // Single-player
                        kModeMP = 0x2  // Multi-player
                    };

                    // Intrusive nodes allocated by LoadChunksTxt()
                    // name -> bitset of chunk IDs
                    struct ChunkSetNode 0x30 {
                        ChunkSetNode* m_next;
                        ChunkSetNode* m_prev;
                        char* m_name [[utf8*]]; 
                        uint64_t m_chunkMaskLo;
                        uint64_t m_chunkMaskHi;
                    };

                    // id -> name
                    struct ChunkIdNode 0x20 {
                        ChunkIdNode* m_next;
                        ChunkIdNode* m_prev;
                        uint32_t m_id;
                        char* m_name @ 0x18 [[utf8*]];
                    };

                    // Global/Statics:
                    // - Initial archive pipeline: bin, shaders, common, mp-common, sp-common, first world, dicts.
                    // - World switch is driven by Current/Target name pairs; UpdateInternal schedules MountWorld when they differ.
                    // - Chunk DB uses FixedSizeHeap + hash buckets with the two intrusive node types above.
                    //   Buckets: ChunkIdNode** and ChunkSetNode** (array of heads); list heads: ChunkIdNode*/ChunkSetNode*.
                    // - KMaxCoreArchives = 0x64.
                    // - Job counters: g_pGameLoadingState, g_pStepCounter
                    // - Mutexes: g_PlayGoSpeedMutex, g_PlayGoChunkAvailMutex
                    // - Core archives: g_NumCoreArchives (KMaxCoreArchives = 0x64), g_CoreArchives[]
                    // - World selection: g_WorldNameCurrent/Target, g_WorldCompanionNameCurrent/Target, g_WorldNamePrevious
                    // - SP/MP mode: g_SpMpModeDesired, g_SpMpModeCurrent (GameLoading::SpMpMode)
                    // - Copy/PlayGo flags: g_CopyPhaseFlags/Target; PlayGoFlag{1,2,3}_{Curr,Target}
                    // - Chunk availability: bitset for IDs; event ring (read/write/count/capacity/data)
                    // - Lang & SP/MP slots: Language A/B, TTS menu/gameplay, SPMP A/B/C

                }; // game-loading.cpp
            }

            // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\gamelib\state-script
            namespace state_script {

                struct ScriptCFuncContext 0x208 {
                    ndlib.script.ScriptValue m_args;
                };

                struct CFunctionStack 0x40 {
                    ScriptCFuncContext* m_pScriptCFuncContext;
                    uint32_t m_NumArgs; // number of received arguments
                    uint32_t m_field_c;
                    uint32_t m_FunctionArgs; // number of function arguments (expected)
                    uint64_t m_field_18 @ 0x18;
                    uint64_t m_field_20;
                    uint64_t m_field_28;
                    bool m_field_30;
                    bool m_MakeAllErrorsFatal;
                };

                struct StateScriptConsoleInfo {
                    uint32_t pos_x;
                    uint32_t size_x;
                    uint32_t pos_y;
                    uint32_t size_y;
                    float font_size_x;
                    float font_size_y;
                    bool line_warp;
                };
            }
        }

    // c:\branches\discbot??\t1xfinal-pc-?.?.?\shared\src\common
    namespace common {}
    }

    // c:\branches\discbot??\t1xfinal-pc-?.?.?\t1x\src
    namespace ndgame {
    
        // c:\branches\discbot??\t1xfinal-pc-?.?.?\t1x\src\game
        namespace game {

            struct GameInfo : shared.ndlib.NdGameInfo 0x3B0 {
            bool m_enableNpTrophies +0x148  [[bool*]]
            uint64_t Unk_4968 +0x25f
            }
        
            struct FrameState : shared.ndlib.NdFrameState 0x160 {
              uint64_t Unk[0x2c];
            } 

            // c:\branches\discbot??\t1xfinal-pc-?.?.?\t1x\src\game\player
            namespace player {

            }

            // c:\branches\discbot??\t1xfinal-pc-?.?.?\t1x\src\game\weapon
            namespace weapon {

                // #79C1042C4AB59AA8: hash-table
                struct ScriptWeaponArt {
                    struct WeaponArt {
                        char* m_category [[utf8*]];
                        uint64_t m_processid;
                    }
                
                    uint64_t m_num;
                    uint64_t* m_hashs;
                    WeaponArt** m_defs;
                };
            }
        }
    }

}