#include <NdGameSdk/components/SdkRegenny.hpp>
#include <NdGameSdk/sdkstringid.hpp>

type int 4 [[i32]]
type uint64_t 8 [[u64]]
type uintptr_t 8 [[u64]]
type uint128_t 16 [[u128]]
type vec4 16 [[u128]]
type uint32_t 4 [[u32]]
type size_t 8 [[u32]]
type uint16_t 2 [[u16]]
type uint8_t 1 [[u8]]
type bool 1 [[bool]]
type void 0
type char 1
type wchar_t 2
type float 4 [[f32]]
type double 8
type StringId64 8 [[u64]]
type HANDLE 8 [[u64]]
type CRITICAL_SECTION 40

namespace regenny {

    // c:\branches\discbot??\t2r-pc-?.?.?\shared\src
    namespace shared {
        
        // Forward declared structures.
        namespace ndlib {
            struct FrameParams{};

            namespace render {
                struct WindowContext{};
            }

            namespace script {
                struct ScriptModule{};
             }
        }

        namespace gamelib {
            namespace level {
                struct Level{};
                struct DataLoading{
                    struct PackageDataLoadingVTable{};
                };
            }

            namespace state_script {
                struct ScriptCFuncContext{};
            }
        }

        // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\common
        namespace common {

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\common\win
            namespace win {
                struct NxApp 0x118 {

                    struct NixxesLogger 0x100250 {

                        struct VTable 0x68 {
                            virtual uint64_t Startup() @ 1;
                            virtual bool OpenAndRedirectStdIO() @ 2;
                            virtual void WriteRawLine(char* src) @ 8;
                            virtual void LogF(char* arg2, char* arg3, uint64_t arg4) @ 9;
                        };

                        VTable* vftable;
                        bool m_initialized;
                        void* m_StdOutputHandle @ 0x10; // FILE*
                        uint32_t stdout_fd;
                        uint32_t stderr_fd;
                        uint64_t m_field20;                    
                    };

                    void* m_field0;
                    void* m_field8;
                    void* m_field10;
                    void* m_field18;
                    void* m_field20;
                    NixxesLogger* m_logger;
                }; // nxapp-hooks.cpp
            }
        }

        // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\corelib
        namespace corelib {
            
            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\corelib\memory
            namespace memory {

                enum Context : uint32_t {
                    kAllocInvalid = 0x0,
                    kAllocUnknown = 0x1,
                    kAllocSystemDirect = 0x2,
                    kAllocSystemFlexible = 0x3,
                    kAllocSystemDevelopment = 0x4,
                    kAllocAppCpu = 0x5,
                    kAllocAppCpuLargePage = 0x6,
                    kAllocAppCpuExpanding = 0x7,
                    kAllocAppGpu = 0x8,
                    kAllocAppGpuLargePage = 0x9,
                    kAllocAppFlex = 0xA,
                    kAllocDevCpu = 0xB,
                    kAllocDevCpuLargePage = 0xC,
                    kAllocDevGpu = 0xD,
                    kAllocDevCpuAlways = 0xE,
                    kAllocAnimation = 0xF,
                    kAllocWrappedMalloc = 0x10,
                    kAllocDebugDevMenu = 0x11,
                    kAllocSingleGameFrame = 0x12,
                    kAllocDoubleGameFrame = 0x13,
                    kAllocDoubleGameplayUpdate = 0x14,
                    kAllocGpuStaticRenderTarget = 0x15,
                    kAllocGpuStaticTexture = 0x16,
                    kAllocGpuTexture = 0x17,
                    kAllocGpuTextureStaging = 0x18,
                    kAllocGpuTextureStagingShadow = 0x19,
                    kAllocGpuLevelTexture = 0x1A,
                    kAllocGpuLut = 0x1B,
                    kAllocGpuBuffer = 0x1C,
                    kAllocGpuClothRoBuffer = 0x1D,
                    kAllocGpuClothRwBuffer = 0x1E,
                    kAllocGpuDeformerBuffer = 0x1F,
                    kAllocGpuExposureMapBuffer = 0x20,
                    kAllocGpuExposureMapHeightMaps = 0x21,
                    kAllocGpuDynamicRenderTarget = 0x22,
                    kAllocDevGpuOverflowRenderTarget = 0x23,
                    kAllocGpuShader = 0x24,
                    kAllocGpuDebugShader = 0x25,
                    kAllocScriptData = 0x26,
                    kAllocScriptDataRogue = 0x27,
                    kAllocMenu = 0x28,
                    kAllocLeaderboardData = 0x29,
                    kAllocNetwork = 0x2A,
                    kAllocNetworkProcess = 0x2B,
                    kAllocMovie = 0x2C,
                    kAllocDebugAudioBin = 0x2D,
                    kAllocDebugVoxBin = 0x2E,
                    kAllocVoxTables = 0x2F,
                    kAllocAudioEffects = 0x30,
                    kAllocArmWorkData = 0x31,
                    kAllocPhysics = 0x32,
                    kAllocPhysicsPersistent = 0x33,
                    kAllocPhysicsOverflow = 0x34,
                    kAllocPhysicsSingleFrame = 0x35,
                    kAllocPhysicsDoubleBuffer = 0x36,
                    kAllocDebugPhysicsSingleFrame = 0x37,
                    kAllocParticleDesc = 0x38,
                    kAllocParticleManager = 0x39,
                    kAllocParticleRuntime = 0x3A,
                    kAllocProcess = 0x3B,
                    kAllocLipsync = 0x3C,
                    kAllocWater = 0x3D,
                    kAllocGui2 = 0x3E,
                    kAllocGui2GpuTexture = 0x3F,
                    kAllocIcon = 0x40,
                    kAllocGui2_1 = 0x41,
                    kAllocText2Font = 0x42,
                    kAllocCustom = 0x43,
                    kAllocAlignCache = 0x44,
                    kAllocGestureCache = 0x45,
                    kAllocIkData = 0x46,
                    kAllocNdgi = 0x47,
                    kAllocRenderPool = 0x48,
                    kAllocNdrg = 0x49,
                    kAllocDebugBlockmeshMgr = 0x4A,
                    kAllocGameToGpuRing = 0x4B,
                    kAllocDoubleGameToGpuRing = 0x4C,
                    kAllocRenderToGpuRing = 0x4D,
                    kAllocDoubleRenderToGpuRing = 0x4E,
                    kAllocGameToGpuResourceRing = 0x4F,
                    kAllocRenderToGpuResourceRing = 0x50,
                    kAllocDevGameToGpuRing = 0x51,
                    kAllocDevRenderToGpuRing = 0x52,
                    kAllocDevGameToGpuResourceRing = 0x53,
                    kAllocDevRenderToGpuResourceRing = 0x54,
                    kAllocCpuAccessOnlyRingTag = 0x55,
                    kAllocDoubleCpuAccessOnlyRingTag = 0x56,
                    kAllocGpuUploadRingTag = 0x57,
                    kAllocGpuReadbackRingTag = 0x58,
                    kAllocSingleRenderFrame = 0x59,
                    kAllocRenderGlobals = 0x5A,
                    kAllocPsoCacheTag = 0x5B,
                    kAllocConstBufferMgr = 0x5C,
                    kAllocPackagePageHdrs = 0x5D,
                    kAllocNpcGlobals = 0x5E,
                    kAllocPathfindManager = 0x5F,
                    kAllocRainMgr = 0x60,
                    kAllocHud = 0x61,
                    kAllocDevMenuLowMem = 0x62,
                    kAllocProcessMgr = 0x63,
                    kAllocComponentMgr = 0x64,
                    kAllocPlayerGlobals = 0x65,
                    kAllocClothCompute = 0x66,
                    kAllocEventQueueScript = 0x67,
                    kAllocEventQueueBucket = 0x68,
                    kAllocEventQueueMenu = 0x69,
                    kAllocVoxRequest = 0x6A,
                    kAllocPsarcStatic = 0x6B,
                    kAllocPsarcDynamic = 0x6C,
                    kAllocVegetation = 0x6D,
                    kAllocScreamPluginEventQueue = 0x6E,
                    kAllocWavetableSynth = 0x6F,
                    kAllocLodManager = 0x70,
                    kAllocDeltaBitstream = 0x71,
                    kMaxNumContexts = 0x72,
                    kAllocSingleFrame = 0x73,
                    kAllocGpuRing = 0x74,
                    kAllocRenderResourceRingTag = 0x75,
                    kAllocDoubleGpuRing = 0x76,
                    kAllocDevGpuRing = 0x77,
                    kAllocDevRenderResourceRing = 0x78
                };

                enum MapId : uint32_t {
                    ALLOCATION_PRX_DIRECT_MEM = 0x01,
                    ALLOCATION_APP_CPU_LARGE_PAGE_MEMORY = 0x02,
                    ALLOCATION_CPU_MEMORY = 0x03,
                    ALLOCATION_APP_GPU_LARGE_PAGE_MEMORY = 0x04,
                    ALLOCATION_GPU_MEMORY = 0x05,
                    ALLOCATION_REQUIRED_PRX_FLEX_MEM = 0x06,
                    ALLOCATION_CODE_AND_DATA = 0x07,
                    ALLOCATION_THREAD_CONTEXTS = 0x08,
                    ALLOCATION_PRX_FLEX_MEM = 0x09,
                    ALLOCATION_APP_FLEX_MEM = 0x0A,
                    ALLOCATION_DEV_CODE_AND_DATA = 0x0B,
                    ALLOCATION_DEV_PRX_MEM = 0x0C,
                    ALLOCATION_DEV_CPU_MEM = 0x0D,
                    ALLOCATION_DEV_CPU_LARGE_PAGE_MEMORY = 0x0E,
                    ALLOCATION_DEV_GPU_MEM = 0x0F,
                    ALLOCATION_SCOPED_TEMP_ALLOCS = 0x21,
                    ALLOCATION_SCREAM_SND_MEM_USE_STREAMING = 0x7C,
                    ALLOCATION_SCREAM_SOUND_BANK_HEAP = 0x7D,
                    ALLOCATION_AUDIO_EFFECTS = 0x43,
                    ALLOCATION_LOADING_HEAP = 0x55,
                    ALLOCATION_LOADING_HEAP_HIDDEN = 0x56,
                    ALLOCATION_GAMEPLAY_LOADING_HEAP = 0x57,
                    ALLOCATION_GAMEPLAY_LOADING_HEAP_HIDDEN = 0x58,
                    ALLOCATION_PSO_PRE_LOADING_HEAP = 0x59,
                    ALLOCATION_PROCESS_HEAP = 0x70,
                    ALLOCATION_ANIMATION_HEAP = 0x72,
                    ALLOCATION_NDGI_HEAP = 0xB1,
                    ALLOCATION_RENDER_POOL_HEAP = 0xB3,
                    ALLOCATION_PHYSICS_MEMORY = 0x6C,
                    ALLOCATION_ICON = 0xD2,
                    ALLOCATION_GUI2 = 0xA4,
                    ALLOCATION_GUI2_STREAMING = 0xA5,
                    ALLOCATION_GUI2_PRIMITIVE_HEAP = 0xA6,
                    ALLOCATION_TEXT2_FONT = 0xA3,
                    ALLOCATION_WAVETABLE_SYNTH = 0xA8,
                    ALLOCATION_DELTA_BITSTREAM_HEAP = 0xAA,
                    ALLOCATION_TAGGED_HEAP = 0x23,
                    ALLOCATION_SINGLE_GAME_FRAME = 0x25,
                    ALLOCATION_DOUBLE_GAME_FRAME = 0x26,
                    ALLOCATION_DOUBLE_GAMEPLAY_UPDATE = 0x27,
                    ALLOCATION_SINGLE_RENDER_FRAME = 0xB4,
                    ALLOCATION_GAME_TO_GPU_RING = 0xB5,
                    ALLOCATION_DOUBLE_GAME_TO_GPU_RING = 0xB6,
                    ALLOCATION_RENDER_TO_GPU_RING = 0xB7,
                    ALLOCATION_DOUBLE_RENDER_TO_GPU_RING = 0xB8,
                    ALLOCATION_RESOURCES_TO_GPU_RING = 0xB9,
                    ALLOCATION_NET_SNAPSHOT_NODE = 0xBA,
                    ALLOCATION_CPU_ACCESS_ONLY_RING = 0xBB,
                    ALLOCATION_SHADER = 0xCA,
                    ALLOCATION_TEXTURE_READING = 0xDE,
                    ALLOCATION_APP_CPU_LARGE_PAGE_UNACCOUNTED = 0x10,
                    ALLOCATION_APP_CPU_LARGE_PAGE_FREE = 0x11,
                    ALLOCATION_WRAPPED_MALLOC_POOL = 0x22,
                    ALLOCATION_IK_DATA = 0x53,
                    ALLOCATION_MENU_HEAP = 0x5E,
                    ALLOCATION_LEADERBOARD_DATA = 0x5F,
                    ALLOCATION_MUSIC_MGR = 0x60,
                    ALLOCATION_PARTICLE_DESC = 0x69,
                    ALLOCATION_PARTICLE_MGR = 0x6A,
                    ALLOCATION_PARTICLE_RUNTIME = 0x6B,
                    ALLOCATION_PHYSICS_PERSIST = 0x6D,
                    ALLOCATION_PRINTF_STATIC_BUFFER_MEM = 0x6E,
                    ALLOCATION_TEXTDB_MEM = 0x92,
                    ALLOCATION_DYNAMIC_LIGHT_MEM = 0xAE,
                    ALLOCATION_FIOS_MEM_POOL = 0x50,
                    ALLOCATION_PACKAGE_ARRAY = 0x66,
                    ALLOCATION_PACKAGE_PAGE_HEADERS = 0x68,
                    ALLOCATION_CBUFFER_MGR = 0x46,
                    ALLOCATION_FONTS = 0x51,
                    ALLOCATION_LEVEL_DEFS = 0x5A,
                    ALLOCATION_LEVEL_STREAMING_MGR = 0x5B,
                    ALLOCATION_LVLMGR = 0x5C,
                    ALLOCATION_SCRIPT_HEAP = 0x82,
                    ALLOCATION_SCRIPT_RELOC_HEAP = 0x85,
                    ALLOCATION_SCRIPT_ROGUE = 0x86,
                    ALLOCATION_SCRIPT_STACK_FRAMES = 0x87,
                    ALLOCATION_SCRIPT_SCOPED_ALLOCATIONS = 0x88,
                    ALLOCATION_SCRIPT_SYMBOL_TBL = 0x89,
                    ALLOCATION_PROCESS_MGR = 0x6F,
                    ALLOCATION_TASK_GRAPH = 0x91,
                    ALLOCATION_MESH_RAY_CASTER = 0xB0,
                    ALLOCATION_ARM_PROCESS = 0x3E,
                    ALLOCATION_ARM_PUSHBUFFER = 0x3F,
                    ALLOCATION_ARM_WORKDATA = 0x40,
                    ALLOCATION_SCREAM_SND_MEM_USE_SYNTH = 0x78,
                    ALLOCATION_SCREAM_SND_MEM_USE_SCRIPTING = 0x79,
                    ALLOCATION_SCREAM_SND_MEM_USE_CCS = 0x7A,
                    ALLOCATION_SCREAM_SOUND_BANK_DS_HEAP = 0x7E,
                    ALLOCATION_SCREAM_PLUGIN_EVENT_QUEUE_HEAP = 0x81,
                    ALLOCATION_SOUND_VIRTUAL_BANK = 0x90,
                    ALLOCATION_NCA_BATCH = 0x61,
                    ALLOCATION_VIBRATION_MANAGER = 0xA7,
                    ALLOCATION_HTTP_POOL_SIZE = 0x34,
                    ALLOCATION_FG_ANIM_DATA = 0x49,
                    ALLOCATION_FG_ANIM_IDENTITY_MATS = 0x4A,
                    ALLOCATION_FG_DRAW_DATA = 0x4C,
                    ALLOCATION_FG_ANIMCMD_DATA = 0x4B,
                    ALLOCATION_FG_KILLER = 0x4F,
                    ALLOCATION_HUD = 0x52,
                    ALLOCATION_SAVE_MANAGER = 0x76,
                    ALLOCATION_SAVE_CHECKPOINT = 0x75,
                    ALLOCATION_BODY_MANAGER = 0x44,
                    ALLOCATION_LIP_SYNC_BUFFER = 0x54,
                    ALLOCATION_WATER = 0xD1,
                    ALLOCATION_RENDER_GLOBALS = 0x73,
                    ALLOCATION_PSO_CACHE = 0xDC,
                    ALLOCATION_REDIS = 0x38,
                    ALLOCATION_REDIS_LARGE = 0x39,
                    ALLOCATION_DMENU_LOWMEM = 0x47,
                    ALLOCATION_AUDIO_VOX = 0x41,
                    ALLOCATION_AUDIO_VOX_TABLES = 0x42,
                    ALLOCATION_SIMPLE_NPC = 0x8E,
                    ALLOCATION_VEGETATION = 0x97,
                    ALLOCATION_GAME_CONFIG = 0x98,
                    ALLOCATION_ANIM_STREAMING = 0x99,
                    ALLOCATION_ANIM_CHAIN = 0x9A,
                    ALLOCATION_ANIM_DUMMY_INSTANCE = 0x9B,
                    ALLOCATION_REGION_TAG_TABLE = 0x9D,
                    ALLOCATION_RAIN_MGR = 0xA0,
                    ALLOCATION_CINEMATICS = 0xA1,
                    ALLOCATION_EVENT_QUEUE_SCRIPT_HEAP = 0x28,
                    ALLOCATION_EVENT_QUEUE_BUCKET_HEAP = 0x29,
                    ALLOCATION_EVENT_QUEUE_MENU_HEAP = 0x2A,
                    ALLOCATION_VOX_REQUEST_HEAP = 0x2B,
                    ALLOCATION_FRAME_PARAMS = 0x2F,
                    ALLOCATION_PREFETCH_BUFFER = 0x30,
                    ALLOCATION_TEXTURE_DICT = 0xDA,
                    ALLOCATION_TEXTURE_REPORTER = 0xD3,
                    ALLOCATION_GESTURE_CACHE = 0x9C,
                    ALLOCATION_RESOURCE_TABLE = 0x3B,
                    ALLOCATION_NDRG_HEAP = 0xB2,
                    ALLOCATION_ANIM_ALIGN_CACHE = 0x3D,
                    ALLOCATION_COMPONENT_MGR = 0x8C,
                    ALLOCATION_SUBSYSTEM_HEAP = 0x8D,
                    ALLOCATION_STATE_SCRIPT = 0x8A,
                    ALLOCATION_SMOKE_TEST = 0x8F,
                    ALLOCATION_FIOS_STATIC_PSARC = 0xD8,
                    ALLOCATION_FIOS_DYNAMIC_PSARC = 0xD9,
                    ALLOCATION_SETTINGS_POOL = 0x8B,
                    ALLOCATION_LVLMGR_NAME_CACHE = 0x5D,
                    ALLOCATION_PACKAGE_MGR_RING_BUFFER = 0x67,
                    ALLOCATION_NP_POOL_1 = 0x35,
                    ALLOCATION_NP_POOL_2 = 0x36,
                    ALLOCATION_HTTP_CACHE = 0x33,
                    ALLOCATION_PLAYGO_HEAP = 0x9E,
                    ALLOCATION_NAV_MESH_MANAGER = 0x62,
                    ALLOCATION_NPC_GLOBALS = 0x63,
                    ALLOCATION_PATHFIND_MANAGER = 0x64,
                    ALLOCATION_FIOS_DEARCHIVER_MEM = 0x31,
                    ALLOCATION_PLAYER_GLOBALS = 0x93,
                    ALLOCATION_RIGIDBODY_DATA = 0x74,
                    ALLOCATION_EVENT_LOG = 0x9F,
                    ALLOCATION_CATMULL_ROM = 0x45,
                    ALLOCATION_FACTS = 0x48,
                    ALLOCATION_PHOTO_MODE = 0x96,
                    ALLOCATION_PAD = 0x3C,
                    ALLOCATION_WIDGET_MANAGER = 0xA9,
                    ALLOCATION_GUI2_GPU = 0xDB,
                    ALLOCATION_CLOTH_COMPUTE = 0xD7,
                    ALLOCATION_LOD_MANAGER = 0xAC,
                    ALLOCATION_DELTA_BITSTREAM = 0xAB,
                    ALLOCATION_VOL_PROBE_LIGHT_CACHE = 0xAD,
                    ALLOCATION_NETWORK_HEAP = 0x94,
                    ALLOCATION_APP_CPU_UNACCOUNTED = 0x12,
                    ALLOCATION_APP_CPU_FREE = 0x13,
                    ALLOCATION_STATIC_TEXTURE = 0xC5,
                    ALLOCATION_TEXTURE = 0xC6,
                    ALLOCATION_GUI2_TEXTURE = 0xC9,
                    ALLOCATION_TEXTURE_STAGING = 0xC7,
                    ALLOCATION_LEVEL_TEXTURE = 0xC8,
                    ALLOCATION_GPU_UPLOAD_RING = 0xBC,
                    ALLOCATION_CLOTH_RO_BUFFER = 0xCD,
                    ALLOCATION_CLOTH_RW_BUFFER = 0xCE,
                    ALLOCATION_GPU_READBACK_RING = 0xBD,
                    ALLOCATION_EXPOSURE_MAP_BUFFER = 0xCF,
                    ALLOCATION_EXPOSURE_MAP_HEIGHTMAPS = 0xD0,
                    ALLOCATION_APP_GPU_UNACCOUNTED = 0x14,
                    ALLOCATION_APP_GPU_FREE = 0x15,
                    ALLOCATION_STATIC_RENDER_TARGET = 0xBE,
                    ALLOCATION_STATIC_NON_RENDER_TARGET = 0xBF,
                    ALLOCATION_STATIC_BUFFER = 0xC0,
                    ALLOCATION_DYNAMIC_RENDER_TARGET = 0xC1,
                    ALLOCATION_DYNAMIC_NON_RENDER_TARGET = 0xC2,
                    ALLOCATION_DYNAMIC_BUFFER = 0xC3,
                    ALLOCATION_LUT = 0xC4,
                    ALLOCATION_DEFORMER_BUFFER = 0xCC,
                    ALLOCATION_RENDER_BUFFER = 0xCB,
                    ALLOCATION_LUT_TABLE = 0xAF,
                    ALLOCATION_APP_GPU_UNACCOUNTED_2 = 0x16,
                    ALLOCATION_APP_GPU_FREE_2 = 0x17,
                    ALLOCATION_JOB_SYSTEM = 0x20,
                    ALLOCATION_FIOS_RAM_CACHE = 0xD4,
                    ALLOCATION_FIOS_PREFETCHER = 0xD6,
                    ALLOCATION_APP_FLEX_UNACCOUNTED = 0x18,
                    ALLOCATION_APP_FLEX_FREE = 0x19,
                    ALLOCATION_OVERFLOW_LOADING_HEAP = 0xE9,
                    ALLOCATION_DEBUG_LOADING_HEAP = 0xEB,
                    ALLOCATION_DEBUG_PSO_PRE_LOADING_HEAP = 0xED,
                    ALLOCATION_OVERFLOW_GAMEPLAY_LOADING_HEAP = 0xEA,
                    ALLOCATION_DEBUG_GAMEPLAY_LOADING_HEAP = 0xEC,
                    ALLOCATION_DEBUG_SHADER = 0xEE,
                    ALLOCATION_DEV_CPU_UNACCOUNTED = 0x1A,
                    ALLOCATION_DEV_CPU_FREE = 0x1B,
                    ALLOCATION_TAGGED_DEV_HEAP = 0x24,
                    ALLOCATION_DEV_RESOURCES_TO_GPU_RING = 0xF7,
                    ALLOCATION_DEBUG_SCREAM_DEBUG = 0xDF,
                    ALLOCATION_DEBUG_SCREAM_SERVER_TTY = 0xE0,
                    ALLOCATION_DEBUG_SCREAM_SERVER_AUDITIONING = 0xE1,
                    ALLOCATION_DEBUG_AUDIO_BIN = 0xE3,
                    ALLOCATION_DEBUG_VOX_BIN = 0xE4,
                    ALLOCATION_PHYSICS_OVERFLOW_MEMORY = 0xE5,
                    ALLOCATION_PROCESS_HEAP_OVERFLOW = 0x71,
                    ALLOCATION_SID_DB = 0x3A,
                    ALLOCATION_PROFILE_SAMPLE_BUFFERS = 0x2C,
                    ALLOCATION_PROFILE_GPU_SAMPLE_BUFFERS = 0x2D,
                    ALLOCATION_PROFILE_CMP_SAMPLE_BUFFERS = 0x2E,
                    ALLOCATION_SCRIPT_MGR_DECI_INPUT = 0x84,
                    ALLOCATION_SCRIPT_DBG_HEAP = 0x83,
                    ALLOCATION_NPC_DEBUG_MEM = 0xE8,
                    ALLOCATION_DEBUG_DMENU = 0xF2,
                    ALLOCATION_DEBUG_ORBIS_EXCEPTION = 0xF3,
                    ALLOCATION_DEBUG_DRAWING = 0xF4,
                    ALLOCATION_MEMORY_TRACKER = 0x32,
                    ALLOCATION_DEV_GAME_TO_GPU_RING = 0xF5,
                    ALLOCATION_DEV_RENDER_TO_GPU_RING = 0xF6,
                    ALLOCATION_PROFILE_TRACE = 0xA2,
                    ALLOCATION_TEXTDB_DEBUG_MEM = 0xF8,
                    ALLOCATION_DEV_SCREEN_CAPTURE = 0xF9,
                    ALLOCATION_FIOS_RAM_CACHE_PERSISTENT = 0xD5,
                    ALLOCATION_DEBUG_BLOCKMESH_MGR = 0xFA,
                    ALLOCATION_DEBUG_TOOLS_MGR = 0xFB,
                    ALLOCATION_DEV_CPU_UNACCOUNTED_2 = 0x1C,
                    ALLOCATION_DEV_CPU_FREE_2 = 0x1D,
                    ALLOCATION_DEV_GPU_TARGET_CAPTURE = 0xEF,
                    ALLOCATION_PS_CAMERA = 0xF0,
                    ALLOCATION_OVERFLOW_DYNAMIC_RENDER_TARGET = 0xFC,
                    ALLOCATION_OVERFLOW_DYNAMIC_NON_RENDER_TARGET = 0xFD,
                    ALLOCATION_OVERFLOW_DYNAMIC_BUFFER = 0xFE,
                    ALLOCATION_DEV_GPU_UNACCOUNTED = 0x1E,
                    ALLOCATION_DEV_GPU_FREE = 0x1F
                };

                struct MemoryMapEntry 0x20 {
                    MapId m_id
                    Context m_context
                    uint64_t m_size
                    uint64_t m_aligned
                    char* m_name [[utf8*]]
                };

                struct BaseAllocator 0x58 {
                    void* vftable;
                    void* m_pTracker @ 0x38;
                    char* m_context_name [[utf8*]];
                    StringId64 m_context_hash;
                    bool m_Initialized;
                };

                struct Allocator : BaseAllocator 0xa8 {

                    struct VTable {
                        virtual uint64_t PostAllocate(uint64_t pSize, uint64_t pAlignment, char* pFunction, uint32_t pLine, char* pFilePath) @ 7;
                    };
                    
                    void* m_Data @ 0xb0;
                    uint64_t m_size @ 0xc8;
                };

                struct HeapAllocator : Allocator 0x20 {
                    char* m_file @ 0x100 [[utf8*]];
                    char* m_function [[utf8*]];
                    uint32_t m_line;
                    bool m_field114;
                };

                struct AllocStack 0x50 {
                    void* m_StackPool;
                    bool m_field30 @ 0x30;
                }; // s_AllocStack

            }

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\corelib\util
            namespace util {

                struct NameCache 0x50 {
                    void* vftable;
                    void* m_bucketTable;
                    void* m_nodePool;
                    void* m_freeList;
                    void* m_allocator;
                    uint32_t m_bucketCount;
                    uint32_t m_entryCount;
                    uint32_t m_nameCapacity;
                    uint32_t m_nameCount;
                    char* m_writePtr;
                    uint32_t m_offset;
                    uint32_t m_stringCount;
                    uint32_t m_cacheSize;
                }; // string-cache.c

                struct MsgCon 0x118 {
                    void* vftable;
                    float m_MsgConScale @0x10;
                    uint32_t m_MsgConLeftPad;
                    uint32_t m_MsgConHorizontalSize;
                    uint32_t m_MsgConVerticalSize;
                    uint32_t m_MsgConTopPad;
                    bool m_PrintTimeInTTY @0x2e;
                    bool m_PrintTTY @0x30;
                    bool m_RedisTTY;
                    bool m_DrawRedisTTYTimes;
                    bool m_DrawRedisTTYStatus;
                    bool m_ApplyMsgConScaletoDebugText @0x36;
                    bool m_EnableMsgConLineWrap;
                    bool m_EnableMsgConAutoResize;
                    bool m_ShowCacheMissesDebugText;
                };
            }

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\corelib\containers
            namespace containers {
                
                struct TaggedHeap 0xDB308 {
                    struct VTable {
                        virtual uint64_t GetBlockSize() @ 0x30
                    } 
                    VTable* vftable;
                }

                struct FixedSizeHeap 0x58 {
                    void* m_data;
                    void* m_block;
                    uint64_t* m_usage;
                    uint64_t m_usageSize;
                    uint64_t m_granularity;
                    uint32_t m_bitmapCount;
                    uint64_t m_capacity @ 0x30;
                    uint64_t m_elementSize;
                    uint64_t m_count;
                    uint64_t m_allocCount;
                    uint64_t m_lastIndex;
                } // fixedsizeheap.h

            }

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\corelib\system
            namespace system {

                // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\corelib\system\platform
                namespace platform {

                    struct ndsys {

                        struct Thread 0x10 {
                            void* m_nativeThread; // HANDLE*
                            uint32_t m_id;
                            uint32_t m_joinable;
                        } // thread.h

                        struct ThreadDesc 0x120 {
                            uint64_t m_stackSize;
                            uint32_t m_priority;
                            uint32_t m_affinity;
                            uint32_t m_flags;
                            char m_name[0x100];
                        }

                        struct Fiber 0x10 {
                            void* m_nativeFiber;
                            void* m_CtxBlock;
                        } // thread.h

                        struct FiberContext 0x280 {
                            // Fiber context data
                            char m_field0[0x40];
                            char m_field40[0x40];
                            char m_field80[0x40];
                            char m_fieldc0[0x40];
                            char m_field100[0x40];
                            char m_field140[0x40];
                            char m_field180[0x40];
                            char m_field1c0[0x40];
                            char m_field200[0x40];
                            char m_field240[0x40];
                        } // thread.h

                        struct Mutex 0x40 {
                            enum Type : uint32_t {
                                MUTEX_RECURSIVE = 0x1
                            };

                            void* m_data;
                            uint32_t m_threadID;
                            uint32_t m_lockCount;
                            Type m_type;
                            bool m_initialized;
                        } // mutex.h

                        struct MutexDesc 0x24 {
                            ndsys.Mutex.Type m_type;
                            char m_name[0x20];
                        };

                        struct ConditionVariable 0x20 {
                            void* m_ConditionVar; // CONDITION_VARIABLE*
                            bool m_initialized;
                        } // condition-variable.h
                    }
                }
            }

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\corelib\job
            namespace job {

                enum JlsContext : uint32_t {
                    jobId = 0x0,
                    workerThreadIndex = 0x1,
                    renderFrameParams = 0x2,
                    CurrentAllocator = 0x3,
                    ScriptStackFrame = 0x6,
                    ScriptCFuncContext = 0x8,
                    ContextProcess = 0xc,
                    ContextPlayer = 0xe
                };

                // 16 bytes
                struct JlsEntry 0x10 {
                    StringId64 m_contextid;
                    uint64_t m_payload;
                };

                // 0x20 × 16 B = 512 B
                struct JlsBlock {
	                JlsEntry slots[0x20];
                };

                struct WorkerThreadDesc 0x200 {

                    struct Config 0x30 {
                       uint64_t m_workerPriority @ 0x8;
                    }

                    void* m_listHead;
                    void* m_listTail;
                    void* m_next;
                    void* m_prev;
                    void* m_waitNext;
                    void* m_waitPrev;
                    void* m_tlsBlock;
                    uint32_t m_flags;
                    uint64_t m_context @ 0x78;
                    Config m_config;
                    uint8_t m_scheduler[0x80] @ 0xb8;
                    void* m_nativeHandle;
                    uint32_t m_threadId;
                    uint32_t m_joinable;
                    void* m_threadTLS;
                    uint64_t m_waitCookie;
                    uint8_t m_shuttingDown;
                };
                
                struct WorkerInitContext 0x420 {
                    regenny.shared.corelib.system.platform.ndsys.Thread m_Thread @ 0x30;
                    WorkerThreadDesc m_WorkerThreadDesc @ 0x80;
                    regenny.shared.corelib.system.platform.ndsys.Fiber* m_fiber;
                    regenny.shared.corelib.system.platform.ndsys.ThreadDesc m_ThreadDesc;
                    char m_longName[0x20] @ 0x400 [[utf8*]];
                };

                struct JobHeap 0x98 {
                    corelib.containers.FixedSizeHeap m_Heap;
                    uint64_t m_field88 @ 0x88;
                    uint32_t m_field90;
                    uint32_t m_field94;
                };

                struct JobSystem 0x10 {
                    bool m_EnableStackChecking @ 0x8;
                    bool m_field9;
                    bool m_PrintJobSysDataStats;
                    bool m_EnableValidation;
                    bool m_EnablePerfCounters;
                    bool m_EnableDeadlockDetection @ 0xe;
                }; // s_JobSystem

                struct ndjob {

                    enum Priority : uint32_t {
                        KInvalid = 0xff,
                        KHigh = 0x1,
                        KNormal = 0x2,
                        KLow = 0x3
                    };

                    enum JobFlag : uint32_t {
                        None = 0x00,
                        // Allows for larger stack sizes.
                        LargeStack = 0x01,
                        // Marks job as part of the per-frame pipeline (logic/update side).
                        GameFramePhase = 0x04,
                        // Marks job as part of the render-frame pipeline (graphics side).
                        RenderFramePhase = 0x08,
                        // Writes a per-worker mask to [slot+0x80].
                        PinToCurrentWorker = 0x20,
                        // Used on the FrameSpawner job (root/system spawner).
                        FrameSpawner = 0x40,
                        // Skip perf timestamping at start/end.
                        SkipTiming = 0x80
                    };

                    enum CounterWakePolicy : uint32_t {
                        WakeOnEveryDecrement = 0x0,
                        WakeOnlyAtZero = 0x1, 
                    };

                    struct InitParams 0x78 {
                        void* m_pMemoryBuffer;
                        uint64_t m_memoryBufferSize;
                        void* m_pDebugMemoryBuffer;
                        uint64_t m_DebugMemoryBufferSize;
                        uint64_t m_numCounters;
                        uint64_t m_numJobArrays;
                        uint64_t m_numWorkerThreads;
                        void* m_field38;
                        uint16_t m_flags;
                        uint64_t m_field48 @ 0x48;
                        uint64_t m_maxSmallJobFibers;
                        uint64_t m_maxLargeJobFibers;
                        uint64_t m_smallJobFiberStackSpace;
                        uint64_t m_largeJobFiberStackSpace;
                        bool m_field70;
                    };

                    struct CounterHandle 0x40 {
                        char* m_file [[utf8*]];
                        uint32_t m_line;
                        char* m_function  @ 0x10 [[utf8*]];
                        uint64_t m_timestampQPC;
                        void* m_waitListHead;
                        uint64_t m_field28;
                        uint32_t m_CountJobArrays @ 0x30;
                        CounterWakePolicy m_wakeFlags @ 0x38;
                    };

                    struct JobHeader 0x80 {
                        void* m_entry; // Entry function
                        void* m_WorkData; // User data
                        CounterHandle* m_Counter;
                        CounterHandle* m_queuePrev;
                        CounterHandle* m_waitNext;
                        void* m_tlsBlock @ 0x30;
                        uint32_t m_stateBits;
                        uint64_t m_flags @ 0x40;
                    };

                    struct JobArrayHeader 0x100 {
                        uint32_t m_completedCount;
                        uint32_t m_writeIndex;
                        uint32_t m_issuedCount;
                        uint32_t m_jobCapacity;
                        JobHeader* m_JobStorage; // array of JobHeader
                        CounterHandle* m_JobCounter;
                        uint64_t m_field20;
                        uint32_t m_field28;
                        uint64_t m_allowedWorkersMask + 0x4;
                        void* m_heapBlock;
                        uint8_t m_state;
                        Priority m_priority @ 0x44;
                        uint64_t m_QueryPerformance @ 0x50;
                        uint64_t m_WorkerThreadIndex;
                    };

                    struct SchedLane 0x4080 {
                        JobArrayHeader* m_slots[0x800];
                        uint64_t m_count;
                    };

                    // Notice: Be careful with the offsets in the Data structures,
                    // they too sensitive to changes
                    struct SysData 0xc0 {
                        bool m_Initialized;
                        char m_field1[0xbf];
                    };

                    struct CounterData : SysData 0x180 {
                        uint64_t m_fieldf8 + 0xf8;
                        CounterHandle* m_Counters;
                        uint32_t m_maxSlots;
                        uint32_t m_nextFree;
                        uint32_t m_initialized;
                        void* m_heapBlock + 0x2c;
                    };

                    struct JobArrayData : SysData 0x200 {
                        uint64_t m_fieldf8 + 0xf8;
                        JobArrayHeader* m_JobArrays;
                        uint32_t m_maxHeaders;
                        uint32_t m_topIndex;
                        uint32_t m_initialized;
                        void* m_heapBlock + 0x1c;
                    };

                    struct FiberData : SysData 0x100 {
                        regenny.shared.corelib.system.platform.ndsys.FiberContext* m_FiberCtx;
                        regenny.shared.corelib.system.platform.ndsys.Fiber* m_smallFiberPool;
                        regenny.shared.corelib.system.platform.ndsys.Fiber* m_largeFiberPool;
                    };

                    struct WaitData : SysData 0x80 {
                        void* m_field8 + 0x8;
                        uint32_t m_field10;
                        uint32_t m_flags;
                        bool m_Initialized;
                        JobArrayHeader** m_JobStorage + 0x7; // array of JobArrayHeader*
                        JobArrayHeader* m_WaitingJobs;
                        JobArrayHeader* m_field30;
                        uint64_t m_numWaitingJobs;
                    };

                    struct WakeUpData : SysData 0x20280 {
                        // Not analyzed in detail
                        char m_field0[0x20204];
                        char m_field20204[4];
                        char m_field20208[4];
                        char m_field2020c[4];
                        char m_field20210[0xc];
                        char m_field2021c[4];
                        char m_field20220[4];
                        char m_field20224[4];
                        char m_field20228[0x18];
                        char m_field20240[0x40];
                    };

                    struct SchedData : SysData 0x100 {
                        SchedLane* m_lanes;
                    };

                    struct JobSysData 0x26d80 {
                        InitParams m_initParams;
                        bool m_IsQuit;
                        uint32_t m_readyWorkerCount @ 0x80;
                        uint64_t m_field90 @ 0x90;
                        uint64_t m_field98;
                        uint64_t m_fielda0;
                        uint64_t m_fielda8;
                        bool m_IsPowerSaveMode;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_PowerSaveLocks[0x18] @ 0xe0;
                        regenny.shared.corelib.system.platform.ndsys.ConditionVariable m_cvFreeJob[0x18];
                        regenny.shared.corelib.system.platform.ndsys.Thread m_workerThreads[0x18];
                        uint64_t m_numWorkerThreads;
                        void* m_hWorkerReadyEvent;
                        uint64_t m_workerMaskLo;
                        uint64_t m_workerMaskHi;
                        WorkerThreadDesc m_workerInfo[0x18] @ 0xc00;
                        SysData m_SysStatsData @ 0x54c0;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_StatsDataLock @ 0x5580;  
                        CounterData m_CounterData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_CounterDataLock @ 0x5800;
                        JobArrayData m_JobArrayData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_JobArrayDataLock @ 0x5b00;
                        FiberData m_FiberData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_FiberDataLock @ 0x5d00;
                        WaitData m_WaitData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_WaitDataLock @ 0x5e80;
                        WakeUpData m_WakeUpData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_WakeUpDataLock @ 0x026200;
                        SchedData m_SchedData;
                        regenny.shared.corelib.system.platform.ndsys.Mutex m_SchedDataLock[0x9] @ 0x026400;
                    };
                }
            }
        }

        // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib
        namespace ndlib {

            struct EngineComponents {
                enum Component : uint32_t {
                    NdGameInfo = 0x0,
                    NdFrameState = 0x1,
                    PhotoModeManager = 0x2,
                    FileSystem = 0x3,
                    PackageMgr = 0x4,
                    PrefetchMgr = 0x5,
                    LevelMgr = 0x6,
                    LevelStreamingMgr = 0x7,
                    NdMessageManager = 0x8,
                    PSNTelemetry = 0xA,
                    AudioManager = 0xB,
                    NdDialogManager = 0xE,
                    NavMeshMgr = 0xF,
                    musicManager = 0xd,
                    NpcManager = 0x10,
                    AnimMgr = 0x11,
                    FgDrawMgr = 0x12,
                    ProcessMgr = 0x13,
                    ScriptManager = 0x14,
                    AnimStreamManager = 0x15,
                    Gui2 = 0x17,
                    TextureMgrPub = 0x18,
                    ParticleDebug = 0x1D
                }; // engine-components.hpp
            }

            struct NdConfig {
                enum Config : uint32_t {
                    NetInfo = 0x0, // m_pNetInfo
                    DMENU = 0x1,
                    NdDevMenu = 0x2,
                    NameCache = 0x7, // m_pNameCache
                    BUILD_NUMBER = 0x1e,
                    GameTitle = 0x20,
                    Profiling = 0xd1,
                    IsGameConfigured = 0xd2
                }; // nd-config.hpp
            }

            struct NdGameInfo 0x4660 {
                void* vftable;
                char* m_internalname @ 0x118 [[utf8*]];
                StringId64 m_gametitlehash @ 0x120;
                char m_buidtype[0x128] @ 0x128 [[utf8*]]; // IDK
                char m_SavePath[0x400] @ 0x548 [[utf8*]];
                char m_GamePath[0x400] [[utf8*]]; 
                char m_GamePath_unk[0x400] [[utf8*]]; 
                char m_NetUserPath[0x400] [[utf8*]]; 
                char m_NetPath[0x400] [[utf8*]]; 
                char m_GameDataPath[0x400] [[utf8*]]; 
                char m_GameDataPath_unk[0x400] [[utf8*]]; 
                char m_BinPath[0x400] [[utf8*]]; 
                char m_BinPath_unk[0x400] [[utf8*]];
                char m_BranchName[0x40] [[utf8*]]; 
                char m_SrcPath[0x400] [[utf8*]]; 
                char m_DbPath[0x400] [[utf8*]]; 
                char m_GamePath_unk2[0x400] [[utf8*]];
                char m_CfgPath[0x400] @0x398a [[utf8*]]
                char m_CfgFolderName[0x80] @ 0x3d8a [[utf8*]];
                char m_CfgDefaultsPath[0x80] [[utf8*]];
                bool m_AssetView @ 0x3f11 [[bool*]];
                bool m_DevConfig @ 0x3f12 [[bool*]];
                bool m_onDisc [[bool*]];
                bool m_onDiscUseManifest [[bool*]];
                uint32_t m_env @ 0x3f0c; // environment enum
                bool m_IsMultiplayer @ 0x3f3c [[bool*]];
                bool m_DevMode @ 0x3f50 [[bool*]];
                bool m_DebugRendering @ 0x3f5e [[bool*]];
                bool m_DisableFpsStat @ 0x3f88 [[bool*]];
                bool m_MsgConDrawBuffers @ 0x3fa8 [[bool*]];
                bool m_showBuildInfo @ 0x3f9a [[bool*]];
                char m_DiscUser[0x20] @ 0x4030 [[utf8*]];
                char m_StatsBuild[0x20] @ 0x40a4 [[utf8*]];
                StringId64 AudioStringId @ 0x41B0;
                bool m_ShowStats @ 0x442f [[bool*]];
                char m_GameStudio[0x40] @ 0x44E3 [[utf8*]];
                uint64_t Unk_4658 @ 0x4658;
            }

            struct NdFrameState 0x29518 {
                
                struct NdKeyboardLayer 0x1A60 {
                    bool m_enabled;
                    bool m_DebugKeyboard;
                    uint64_t m_keysPressed[4] @ 0x8; // 0x008-0x027
                    uint64_t m_keyState[4]; // 0x028-0x047
                    uint64_t m_keyState2[4]; // 0x048-0x067
                    uint64_t m_keys[4]; // 0x068-0x087  (current down mask)
                    uint64_t m_keyState3[4]; // helper masks (auto-repeat, etc.)
                    uint64_t m_keyCodes[4];
                    uint8_t scratch[0x80]; // zeroed in ctor
                    uint64_t m_invalid[4];
                    float m_repeatDelay @ 0x168; // 0.5 s   (3F000000h)
                    float m_repeatRate; // 0.1 s   (3DCCCCCDh)
                    uint32_t m_maxKeyCode; // r8d in ctor
                    uint64_t m_firstRepeatT @ 0x178; // initialised to -0x4000…
                    uint64_t m_nextRepeatT;
                    uint64_t m_keyTime[0x100]; // per-key timestamps (256 × 8 B)
                    NdKeyboardLayer* ring[8] @0x9C8; // layer ring-buffer pointers
                    uint32_t layerIndex @ 0xD28; // [rcx+0xD28] = edx in ctor
                };

                void* vftable;
                uint32_t m_TargetFramerate @ 0x20;
                uint32_t m_MinimumFramerate @ 0x28;
                uint32_t m_speed;
                uint64_t m_gameFrameNumber @ 0x40;
                bool m_KeyboardDevMode @ 0xe5c0;
                NdKeyboardLayer m_IMEKeyboard @ 0x10a10;
                NdKeyboardLayer m_kbdLayer1;
                NdKeyboardLayer m_kbdLayer2;
                NdKeyboardLayer m_GameKeyboard;
                NdKeyboardLayer m_kbdLayer4;
                NdKeyboardLayer m_kbdLayer5;
            } // nd-frame-state.hpp

            struct FrameParams 0x17900 {
                
                // kFrameParamsCount = 0x12;

                struct InitParams 0x368 {
                    FrameParams* m_ringBase; // [kFrameParamsCount]
                    uint64_t m_poolSlice0;
                    uint64_t m_poolSlice1;
                    uint64_t m_poolSlice2;
                    uint64_t m_poolSlice3;
                    uint64_t m_poolSlice4;
                    uint64_t m_poolSlice5;
                }; // s_FrameParams

                uint64_t m_frameNumber;
                void* m_gfxEopTick @ 0x58;
                void* m_DynamicRenderContext @ 0x6a80;
                void* m_pExposureMapComputeContext @ 0x134f0;
                void* m_pExposureMapLastLabel;
                void* m_pRenderCamera @ 0x13530;
                void* m_pUploadQueue @ 0x15240;
                bool m_ArePackageQueuesBusy @ 0x17848;
            } // frame-params.cpp

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib\debug
            namespace debug {

                struct DMENU 0x670 {

                    enum Message : uint32_t
                    {
                        OnOpen = 0x0,
                        OnClose = 0x1,
                        OnUpdate = 0x3,
                        OnExecute = 0x5,
                        OnReadConfig = 0x7,
                        OnSaveConfig = 0x8,
                        OnFocusOut = 0x10
                    };
                
                    // DMENU::Component (class_DMENU::Component_vfTable)
                    struct Component 0xb0 {
                        struct VTable 0xb0 {}
                        void* vftable;
                        void* UnkString;
                        char m_name[0x20] [[utf8*]] // (Only if string length is less than 32 characters)
                        char* m_pname [[utf8*]];
                        Component* m_ParentComponent;
                        Component* m_NextDMenuComponent;
                        uint32_t m_MenuLeftPad;
                        uint32_t m_MenuWidth;
                        uint64_t m_ItemLeftPad;
                        uint64_t Unk2;
                        uint64_t m_data; // For arguments or link variable
                        uint32_t m_color;
                        uint32_t m_selectcolor;
                        uint32_t m_editedcolor; // maybe
                        bool m_Islinked; // BY KEY ID
                        void* m_lazyinitcallback @ 0x78; // Init items after opening menu
                        char* m_pDescription [[utf8*]];
                        bool m_atsign;
                        Component* m_MenuGroup + 0x7;
                        bool m_isfavorite + 0x1;
                        int m_PagePointer + 0x6; // Only with menu component?
                        int m_MaxPagePointers;
                        uint64_t m_ExtraArg;
                    };
                
                    // DMENU::Menu | DMENU::ItemSubmenu
                    struct Menu : Component 0x30 {
                        Component* m_Item;
                        bool m_isActive + 0x4;
                        uint64_t m_pad;
                        int m_MaxDisplayItems @ 0xcc;
                        uint64_t Unk[0x2];
                    };

                    // DMENU::MenuGroup
                    struct MenuGroup : Component 0x280 {
                        Menu* m_RootMenu;
                        bool m_IsDisplayed + 0x8;
                        bool m_Rendering;
                        uint16_t Unk[0x3];
                        uint64_t Unk2[0x4d];
                    };

                    // DMENU::KeyBoard*
                    struct KeyBoard : Component 0x838 {
                        bool m_isEditing;
                        bool m_needsUpdate;
                        bool m_isDirty;
                        bool m_isFrameActive;
                        uint64_t m_cursorIndex @ 0xb8;
                        uint64_t m_lastKey;
                        char m_inputBuffer[0x400] @ 0xd8 [[utf8*]]
                        char m_displayBuffer[0x400] [[utf8*]]
                        char* m_inputBufferPtr [[utf8*]];
                        uint64_t m_maxInputLength;
                    };
                
                    // DMENU::Item (class_Dmenu::Item_vfTable)
                    struct Item : Component 0x8  {
                        struct VTable : DMENU.Component.VTable 0x48 {}
                        void* m_callbackFunct;
                    };

                    // DMENU::ItemSubmenu
                    struct ItemSubmenu : Item 0x10  {
                        Menu* m_pHeader; // Entry Pointer
                        uint64_t Unk[0x1];
                    };

                    // DMENU::ItemBool
                    // Component.m_data - ValuePtr
                    struct ItemBool : Item 0x8 {
                        bool m_status;
                        bool m_pad[0x7];
                    };

                    // DMENU::ItemDecimal* 
                    // Component.m_data - ValuePtr
                    struct ItemDecimal : Item 0xc8  {
                        uint64_t* m_format; // format Printf %d 
                        void* m_HandlerFunc; // handler slider function 
                        uint64_t m_DisplayValue [[i64]];
                        uint64_t UnkDouble [[i64]];
                        uint64_t m_MinValue @ 0xe0 [[i64]];
                        uint64_t m_MaxValue [[i64]];
                        uint64_t m_StepValue [[i64]];
                        uint64_t m_DoubleStepValue [[i64]];
                        char m_StringDisplayValue[0x20] @ 0x140 [[utf8*]];
                        uint64_t Unk[0x4];
                    };

                    // DMENU::ItemFloat
                    // Component.m_data - ValuePtr
                    struct ItemFloat : Item 0xa8  {
                        uint64_t* m_format; // format Printf %6.2f
                        void* m_HandlerFunc; // handler slider function 
                        float m_DisplayValue;
                        float UnkFloat;
                        float m_MinValue @ 0xd4;
                        float m_MaxValue;
                        float m_StepValue;
                        float m_DoubleStepValue;
                        char m_StringDisplayValue[0x20] @ 0x123 [[utf8*]];
                        char Unk[0x1d];
                    };

                    // DMENU::ItemFunction 
                    struct ItemFunction : Item 0x10  {
                        void* unkData; // probably for link key->value
                        bool m_isActive @ 0xc1;
                        bool m_pad[0x6];
                    };

                    // DMENU::ItemSelection*
                    struct ItemSelection : Item 0x38  {
                        void* UnkData; // m_format probably
                        void* m_callbackFormat;
                        uint64_t Unk2[0x3];
                        void* m_SelectionStruct @ 0xe8;
                    };

                    // DMENU::ItemSubText*
                    struct ItemSubText : Item {};

                    // DMENU::String*
                    struct String : Component {};

                    // DMENU::ItemPlaceHolder
                    struct ItemPlaceHolder : Component 0x400 {
                        char m_placeholder[0x400] [[utf8*]];
                    };

                    // DMENU::ItemLine*
                    struct ItemLine : Component {};

                    void* vftable;
                    bool m_Text2DropShadows +0x8
                    bool m_PauseDuringMenus
                    bool m_PauseDuringMenusMP 
                    bool m_Pauseonexit
                    bool m_ShowPausedIndicator
                    bool UnkBool;
                    bool m_SquareButtontoBackOutofMenus
                    bool m_ChordtoSave
                    bool m_AlignMenusRight
                    int  m_Rightmargin @0x1c
                    float m_MenuAlpha [[f32]]
                    float m_MenuScale [[f32]]
                    bool m_Pause @0x61
                    MenuGroup* m_CurrentMenu +0xe [[u64]]
                    MenuGroup* m_QuickMenu
                    MenuGroup* m_DevMenu [[u64]]
                    MenuGroup* m_FavoritesMenu [[u64]]
                    uint64_t Unk2[0xbc];
                };

            }

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib\render
            namespace render {

                enum WindowContextType : uint32_t
                {
                    Context0 = 0x0,
                    Context1 = 0x1,
                    Context2 = 0x2,
                    Context3 = 0x3,
                    Context4 = 0x4,
                    Context5 = 0x5,
                    Context6 = 0x6,
                    Context7 = 0x7,
                    Context8 = 0x8
                };
                
                struct WindowContext 0x30 {
                    WindowContextType m_ContextType;
                    void* FrameParams;
                    uint64_t field_10;
                    uint64_t field_18;
                    uint64_t field_20;
                    uint64_t field_28;
                }

                // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib\render\text
                namespace text {
                    struct DebugStringBase 0x48 {
                        void* vftable;
                        uint64_t unk08;
                        vec4 vec;
                        uint32_t color;
                        float scale;
                        uint8_t fade;
                        uint64_t reserved @ 0x2c;
                        uint32_t field_34;
                        uint64_t field_38;
                        char* pText  @ 0x40 [[utf8*]];
                    }
                }

                // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib\render\util
                namespace util {

                    struct PrimServer 0x1380 {
                    
                        struct VTable 0x210 {
                            virtual void Render(ndlib.render.WindowContext* WindowContext) @ 1
                            virtual void Render2D(ndlib.render.WindowContext* WindowContext) @ 2
                            virtual void Render3D(ndlib.render.WindowContext* WindowContext) @ 3
                            // virtual void RenderLine(_, _, _) @ 20
                            virtual uint64_t RenderString(text.DebugStringBase* header, void* DebugPrimParams, void* BoundFrame) @ 25
                            virtual void InitFrameParams(ndlib.FrameParams* RenderFrameParams) @ 55
                            virtual void ClearAll() @ 56
                            virtual void ReleaseMem() @ 57
                            virtual void ReleaseFrameHeap() @ 58
                            virtual void SetPaused(bool arg2, bool arg3, int arg4) @ 59
                            virtual void CullStale() @ 60
                        } 
                    
                        struct InitParams 0x4c {
                            uint32_t m_memoryBufferSize[0x13];
                        }
                    
                        VTable* vftable;
                    }
                }
            }

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib\profiling
            namespace profiling {
                struct ProfileCtrl 0x70 {};
                struct ProfileMgr 0x1e50 {
                    uint64_t m_numWorkerThreads @ 0x420;
                    corelib.containers.FixedSizeHeap m_FixedSizeHeap @ 0x1db8;
                }; // s_ProfileMgr
            }

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib\util
            namespace util {
                struct BitReader 0x18 {
                    uint64_t m_FixUpTable;
                    uint32_t m_bitIndex;
                    uint32_t m_byteIndex;
                    uint32_t m_size;
                    uint32_t field_14;
                }; // bit-reader.h
            }
            
            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib\script
            namespace script {

                // #lang dc
                namespace DC {
                    struct Entry 0x18 {
                        StringId64 m_scriptId;
                        StringId64 m_typeId;
                        void* m_entryPtr;
                    };   
                
                    struct Header 0x20 {
                        uint32_t m_magic;
                        uint32_t m_versionNumber;
                        uint32_t m_textSize;
                        uint32_t unk;
                        uint32_t unk1;
                        uint32_t m_numEntries;
                        Entry* m_pStartOfData;
                    };

                    // @ map
                    struct map {
                        uint64_t m_size;
                    };
                    
                    // @ modules.bin
                    namespace modules {
                    
                        /*
                           @ file: modules.bin
                           @ ScriptId: *modules*
                           @ TYPE: module-info-array
                           @ EntryPtr: ModuleInfoArray
                        */ 
                        struct modules {
                        
                            // @ symbol-array
                            struct ModuleUnkCollection 0x10 {
                                uint64_t m_num;
                                StringId64* m_pArray; // @ Array
                            };
                        
                            // @ symbol-array
                            struct ModuleCollection 0x10 {
                                uint64_t m_num;
                                StringId64* m_modules; // @ Array
                            }   

                            // @ Array
                            struct ModuleInfo 0x28 {
                                char* m_name [[utf8*]];
                                StringId64 m_hash;
                                uint64_t m_size;
                                ModuleCollection* m_pCollection;
                                ModuleUnkCollection* m_unkCollection;
                            }   

                            // @ module-info-array
                            struct ModuleInfoArray 0x10 {
                                uint64_t m_numModules;
                                ModuleInfo* m_modules;
                            };   
                        }
                    }

                }

                struct ScriptValue {
                    uint64_t val[0x10];
                };

                struct ScriptCFunc 0x10 {
                    struct VTable 0x8 {
                        virtual void CallScriptCFunc(gamelib.state_script.ScriptCFuncContext* CFuncContext, uint32_t ArgsNum, ScriptValue* return_, uint64_t arg4) @ 0;
                    };

                    VTable* vftable;
                    void* m_pFunction;
                };

                // script-module-loader.cpp
                // List<ModuleRequest>
                struct ModuleRequest 0x40 {
                
                    struct ModuleRequestList 0x10 {
                        ModuleRequest* m_head;
                        ModuleRequest* m_tail;
                    }
                
                    ModuleRequest* m_NextModuleRequest;
                    ModuleRequest* m_PrevModuleRequest;
                    StringId64 m_hash;
                    uint64_t m_field18;
                    regenny.shared.corelib.memory.Context m_MemContext;
                    uint32_t m_index;
                    size_t m_size;
                    uint64_t m_field30;
                    bool m_field38; // DEBUG AssetView?
                    bool m_field39;
                    bool m_field3a;
                    bool m_field3b;
                    bool m_field3c;
                    bool m_requested;
                };


                // ScriptManager::ModuleInfo::Constructor
                struct ModuleInfo 0x60 {
                    ModuleInfo* m_NextModule;
                    ModuleInfo* m_PrevModule;
                    char* m_name [[utf8*]];
                    StringId64 m_hash;
                    size_t m_size;
                    uint64_t m_pCollection;
                    uint32_t m_pNumModules;
                    uint64_t m_pUnkCollection @ 0x38;
                    uint32_t m_pNumEntries;
                    ScriptModule* m_ScriptModule @ 0x48;
                    uint64_t m_field50; // if SsScript
                    uint32_t m_field58;
                    bool m_field5c;
                    bool m_IsLocal;
                    bool m_DebugModule;
                    bool m_isLoaded;
                };

                struct LookupDcEntry 0x28 {
                    void* m_entryPtr; // DC::Entry.m_entryPtr
                    ModuleInfo* m_module;
                    StringId64 m_scriptId;
                    StringId64 m_typeId;
                    uint32_t m_field20;
                    uint8_t m_field24;
                };

                struct relocatableModule 0x30 {
                    void* vfTable;
                    uint64_t m_pRecord;
                    uint64_t m_field10;
                    uint64_t m_field18;
                    char* m_ModuleInfoArray [[utf8*]];
                    char* m_ModuleInfoArrayDebug [[utf8*]];
                };
                
                struct ScriptModule 0x70 {
                    struct Loader 0x4e0 {
                        ModuleInfo* m_moduleinfo @ 0x440;
                        uint64_t m_moduleName;
                        corelib.memory.Context m_moduleMemContext;
                        void* m_Data @ 0x480;
                        ScriptModule* m_Module @ 0x4c0;
                        uint64_t m_field4c8;
                        bool m_field4d0;
                        bool m_field4d1;
                        bool m_field4d2;
                        uint16_t m_field4d3;
                        bool m_field4d5;
                        bool m_field4d6;
                    };

                    void* vfTable;
                    ScriptModule* m_NextModule;
                    ScriptModule* m_PrevModule;
                    uint64_t m_field18;
                    char* m_ModuleName [[utf8*]];
                    StringId64 m_modulehash;
                    StringId64 m_field30;
                    uint32_t m_numEntries;
                    DC.Entry* m_Data @ 0x40;
                    ModuleInfo* m_ModuleInfo;
                    DC.Header* m_header;
                    uint64_t m_loadtime;
                    corelib.memory.Context m_moduleMemContext;
                    uint32_t m_field64;
                    uint32_t m_field68;
                    uint32_t m_size;
                };

                struct ModuleBucket 0x98 {
                    uint64_t m_data;
                    corelib.containers.FixedSizeHeap m_heap;
                    uint64_t m_data2;
                    uint32_t m_elementSize;
                    uint64_t m_capacity;
                    uint64_t m_data3;
                    uint64_t field_80;
                    uint64_t field_88;
                    uint32_t field_90;
                    uint32_t m_flags;
                };

                struct ModuleBucketMap 0x1f0 {
                    corelib.containers.FixedSizeHeap m_SymbolsHeap @ 0x8;
                    uint64_t* field_60;
                    uint64_t field_68;
                    uint64_t m_maxGlobalSymbols;
                    void* m_SymbolsHead;
                    void* m_SymbolsTail;
                    uint64_t m_numGlobalSymbols;
                    uint64_t* m_symbolBuckets;
                    ModuleInfo* m_ModulesHead;
                    ModuleInfo* m_ModulesTail;
                    ModuleBucket* m_ModuleBucket;
                    corelib.containers.FixedSizeHeap m_ModulesHeap;
                    uint64_t m_maxModules @ 0x118;
                    uint64_t m_numModules @ 0x130;
                    uint64_t m_ScriptModuleCapacity @ 0x140;
                    ScriptModule* m_ScriptModulesHead;
                    ScriptModule* m_ScriptModulesTail;
                    ModuleBucket* m_ScriptModuleBucket;
                    corelib.containers.FixedSizeHeap m_ScriptModuleHeap;
                    uint64_t m_maxScriptModules @ 0x1c8;
                    uint64_t m_numScriptModules @ 0x1e0;
                    uint32_t m_bucketCount;
                    uint32_t m_lookupFlags;
                }

                // script-manager.cpp
                struct ScriptManagerGlobals 0x7a0 {

                    struct ScriptCFuncMap 0x10 {
                        void* m_FunctionsBaseAddress;
                        uint64_t m_FunctionsNum;
                    }

	                StringId64 m_hash @ 0x10;
	                bool m_EnableScriptTrace @ 0x40;
	                bool m_Autoreloadbinfiles @ 0x42;
	                bool m_DisplayRequestedModules;
	                bool m_DumploadlisttoTTY;
	                bool m_Showoverflowedmodules;
	                bool m_ShowScriptErrors;
	                bool m_PrintmodulesCon;
	                bool m_PrintmodulescountsCon;
	                bool m_ShowDebugBinStatusCon;
	                bool m_DumpStateScriptsonStackFrameHighWater @ 0x4c;
	                bool m_EnableScriptModuleCRC32Checks;
	                bool m_field4e;
	                bool m_ValidateModuleSize;
	                bool m_AssertonGlobalSymbolLookup;
	                bool m_EnableScripts;
	                bool m_field52;
	                bool m_field53;
	                bool m_DisableScriptDebugPrims;
	                bool m_DisplayGlobalSymbols;
	                bool m_ModuleIndexInit;
	                bool m_DisableDebugBinSuppressionforGameTasks;
	                bool m_field58;
                    bool m_field5a @ 0x5a;
                    bool m_DisableDebugBins;
                    bool m_field5c;
	                ModuleRequest.ModuleRequestList* m_moduleRequestListActual @ 0x60;
                    ModuleBucketMap m_ModulesBucket;
	                ScriptCFuncMap* m_NativeMap @ 0x288;
	                ScriptModule.Loader* s_SLoadM;
	                void* m_field780 @0x780;
                    ModuleBucketMap* m_DebugModulesBucket @ 0x798;
                } // g_scriptGlobals 
            }

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\ndlib\io
            namespace io {

                namespace PSARC {
                    // big-endian PSARC header
                    struct HeaderBE 0x32 {
                        uint32_t m_magic; // 'PSAR'
                        uint32_t m_version;
                        uint32_t m_compression; // 'zlib'/'lz4f'/... 
                        uint32_t m_tocLength;
                        uint32_t m_tocEntrySize;
                        uint32_t m_fileCount; 
                        uint32_t m_blockSize; 
                        uint32_t m_flags; 
                        uint64_t m_tocOffset; 
                        uint64_t m_tocUncompressedLen;

                        // derived by the parser (the code writes these bytes into the same object):
                        uint8_t m_indexWidth;
                        uint8_t m_tocIsCompressed;
                    };

                    // PSARC TOC entry (big-endian)
                    struct EntryBE 0x1e {
                        uint8_t m_hashNames[0x10];
                        uint32_t m_zsizeIndexBE;
                        uint8_t m_uncompressedSizeBE[0x5];
                        uint8_t m_offsetBE[0x5];
                    };
                };

                enum FhOpenAccess : uint32_t {
                    FHO_ACCESS_READ = 0, // GENERIC_READ
                    FHO_ACCESS_WRITE = 1, // GENERIC_WRITE
                    FHO_ACCESS_READWRITE = 2, // GENERIC_READ | GENERIC_WRITE
                    FHO_ACCESS_RESERVED3 = 3  // coerced to READ
                };

                enum FhOpenFlags : uint32_t {
                   FHOF_ALLOW_CREATE = 0x00000040, // OPEN_ALWAYS / part of CREATE_ALWAYS
                   FHOF_TRUNCATE = 0x00000200, // TRUNCATE_EXISTING / part of CREATE_ALWAYS
                   FHOF_MODE_04 = 0x00000400, // (used by SCE/FIOS path; not consumed by Win32 CreateFileW)
                   FHOF_DIRECT_IO = 0x00001000  // ResolvePath flag + NO_BUFFERING|WRITE_THROUGH on Win32
                };

                struct FhCtx 0x50 {
                    uint64_t m_sizeBytes;
                    uint64_t m_ctimeSec;
                    uint64_t m_ctimeNsec;
                    uint64_t m_atimeSec;
                    uint64_t m_mtimeSec @ 0x28;
                    uint64_t m_mtimeNsec;
                    uint64_t m_sizeAlt @ 0x48;
                };

                struct FhSlot {
                    uint32_t m_fh;
                    FhCtx* m_ctx + 0x4;
                };

                struct FsResult 0x10 {
                    uint32_t m_code;
                    void* m_payload + 0x4;
                };

                struct PathString 0x20 {
                    wchar_t* m_pathPtr [[utf16*]]; // valid only when m_pathCap >= 8
                    uint64_t m_headHi; // upper 8 bytes of the 16-byte inline head (SSO tail)
                    // PathString meta
                    uint64_t m_pathLen; // length in UTF-16 code units
                    uint64_t m_pathCap; // capacity in UTF-16 code units; < 8 => SSO/inline
                };

                struct FileRecord 0x270 {

                    enum HandleObjType : uint32_t {
                        kHandleInvalid = 0x0,
                        kHandleWin32 = 0x1,
                        kHandleDSFile = 0x2
                    };

                    enum FileState : uint32_t {
                        kStateRaw = 0x0,
                        kStateArchive = 0x1
                    };
                    
                    struct RBTreeHeader 0x18 {
                        FileRecord** m_Parent;
                        FileRecord** m_Left;
                        FileRecord** m_Right;
                    };

                    struct HandleObj 0x10 {
                        void* m_obj;  // IDStorageFile || Win32 Handle
                        HandleObjType m_type;
                    };

                    FileRecord* m_left;
                    FileRecord* m_parent;
                    FileRecord* m_right;
                    bool m_isBlack;
                    bool m_isHeader;
                    PathString m_pathStr @ 0x20;
                    FileState m_state @ 0x40;
                    uint64_t m_fileSize @ 0x48;
                    HandleObj m_handleObj;
                    uint32_t m_refCount;
                    uint32_t m_openIndex;
                    wchar_t m_path[0x104];
                };

                struct StorageCore 0x120 {
                    FileRecord.RBTreeHeader* m_recordTreeHead; // sentinel head node;
                    uint64_t m_mapCount; 
                    FileRecord** m_openBegin;
                    FileRecord** m_openEnd;
                    FileRecord** m_openCap;
                    CRITICAL_SECTION m_cs;
                    void* m_dsFactory @ 0x60; // IDStorageFactory*
                    void* m_dsQueue; // IDStorageQueue *
                    bool m_useDirectStorage;
                    void* m_OnProcessSpawnedFunc @ 0x108;
                };

                struct ArchiveSystem 0x50 {

                    enum PriorityGroup : uint32_t {
                        High = 0x0,
                        Low = 0x1
                    };

                    struct Archive 0x468 {
                        uint64_t m_id;
                        PriorityGroup m_priority;
                        uint32_t m_ioHandle;
                        char m_mountPrefix[0x400] [[utf8*]];
                        uint32_t m_mountPrefixLen; // char m_mountPrefix length
                        PSARC.HeaderBE m_psarcHeader @ 0x418;
                        void* m_heapBlock @ 0x450; // (allocation base)
                        void* m_auxPtr; // (uint8_t*)m_heapBlock; points to TOC bytes
                        void* m_lookupRoot; // (Offset40BE*)((uint8_t*)m_heapBlock + m_psarcHeader.m_tocLength)
                    };

                    struct File 0x18 {
                        uint32_t m_ioHandle;
                        uint64_t m_offset;
                        uint64_t m_size;
                    };

                    uint32_t m_count;
                    uint32_t m_capacity;
                    Archive* m_table;
                    uint32_t m_ptrCount;
                    uint32_t m_ptrCap;
                    Archive** m_ptrs;
                    StorageCore* m_storageCore;
                    void* m_grpDefault;
                    uint64_t m_nextId;
                    void* m_rwLock @ 0x40;
                };

                struct FileSystem 0x220 {

                    enum Priority : uint32_t {
                        None = 0x0
                    };

                    struct RamCacheFilterDesc 0x38 {
                        uint64_t m_size;
                        uint64_t m_workBufSize;
                        void* m_WorkBuffer;
                        uint64_t m_field18;
                        char* m_mountPath;
                        uint64_t m_field28;
                    };

                    struct ReadOnlyFileHandle 0x20 {
                        uint32_t m_ioHandle;
                        uint64_t m_offset @ 0x8;
                        uint64_t m_size;
                        bool m_isArchive;
                    };

                    struct ReadOperation 0x18 {
                        HANDLE m_hEvent;
                        FsResult m_FsResult;
                    };

                    struct RemapNode 0x20 {
                        RemapNode* m_next;
                        RemapNode* m_prev;
                        uint64_t m_key;
                        char* m_value;
                    };

                    struct RemapTable 0x98 {
                        RemapNode** m_buckets;
                        corelib.containers.FixedSizeHeap m_heap;
                        RemapNode* m_sentinel;
                        uint64_t m_nodeSize;
                        uint64_t m_capacity;
                        RemapNode** m_bucketsBegin;
                        RemapNode** m_bucketsEnd;
                        uint64_t m_numEntries;
                        uint32_t m_bucketCountMinus1;
                        uint32_t m_flags;
                    };

                    struct FileSystemOverlay 0x60 {
                        bool m_DisplayDataLoadingStatistics;
                        bool m_showFiosOpsDump;
                        bool m_statsMode @ 0x4;
                        bool m_statsModePrev;
                        uint32_t m_peakBucketValue @ 0x8;
                        uint32_t m_peakAvg20;
                        uint32_t m_bucket[0x14];
                    };

                    struct BatchReadItem 0x28 {
                        void* m_dst;
                        uint32_t m_fh;
                        uint64_t m_offset;
                        uint64_t m_length;
                        void* m_field20;
                    };

                    struct BatchResolveItem 0x10 {
                        char* m_path [[utf8*]];
                        uint32_t* m_outFh;
                    };

                    struct ArchiveMount 0x10 {

                        struct Buffer 0x808 {
                            uint64_t m_archiveId;
                            char m_indexPath[0x400] [[utf8*]];
                            char m_mountPrefix[0x400] [[utf8*]];
                        };

                        Buffer* m_pMountBuffer;
                        uint64_t m_sizeBytes;
                    };

                    FileSystemOverlay m_SystemOverlay;
                    corelib.system.platform.ndsys.Mutex m_ReadLock @ 0x60;
                    corelib.system.platform.ndsys.Mutex m_ReadLock2;
                    bool m_initialized;
                    uint64_t m_entireRamCacheSize @ 0xf8;
                    void* m_RamCache;
                    uint64_t m_workBufSize;
                    uint64_t m_workBuf;
                    corelib.memory.Allocator m_allocator @ 0x120;
                };

                struct FileSystemData 0x42450 {

                    struct FsPoolBucket 0x848 {};

                    FsPoolBucket m_pool[0x80] @ 0x10;
                    uint64_t m_initFlag @ 0x42420;
                    ArchiveSystem* m_archive;
                    StorageCore* m_storageCore;
                    void* m_grpAnimations;
                    void* m_grpAudioScripts;
                    void* m_grpDefault;
                };

                struct LoadingHeapMgr {
                    enum LevelHeapType : uint32_t {
                        main = 0x0,
                        gameplay = 0x1,
                        pso_preload = 0x2
                    }
                } // loadingheap-mgr.cpp
                
                // 0x1b40 - t1x
                struct Package 0x1b00 {
                
                    enum PakItem : uint32_t
                    {
                        INTERACTIVE_BG_1 = 0x4f,
                        NAV_MESH_1 = 0x21,
                        PATH_TRACING_1 = 0x49,
                        NURBS_TABLE_1 = 0x1d,
                        MOTION_MATCH_SET_1 = 0x48,
                        VOXELIZATION_1 = 0x46,
                        TEXTURE_TABLE = 0x1,
                        CAMERA_TABLE_1 = 0x1e,
                        PM_FG_PROTOTYPES = 0x32,
                        LEVEL_FLOOR_PATS_1 = 0x30,
                        LEVEL_FLOOR_PATS_2 = 0x3f,
                        TEXTURE_BLOB_TABLE_1 = 0x51,
                        CIN_SEQUENCE_1 = 0x44,
                        SPHERE_TREE_NODE_1 = 0x15,
                        COLLISION_DATA_BACKGROUND = 0x7,
                        JSON_GEOMETRY = 0x18,
                        SPLINE_TABLE = 0x10,
                        GRAPH_TABLE = 0xd,
                        VIS_CHEAT = 0x36,
                        CUTSCENE_DATA = 0xf,
                        LEVEL_PATS_1 = 0x2f,
                        LEVEL_PATS_2 = 0x3e,
                        COLLISION_DATA_HAVOK_BG = 0x2c,
                        PACKAGE_ITEM_LOOKUP = 0xa,
                        INSTANCE_TAGS_1 = 0x35,
                        VERTEX_SHADER_TABLE = 0x2,
                        ANIMATED_LIGHTS = 0x4d,
                        SPECULAR_CUBEMAPSET = 0x3d,
                        LIGHT_TABLE_1 = 0x12,
                        SOUND_BANK_TABLE = 0x31,
                        PM_COLLECTION_1 = 0x16,
                        PM_COLLECTION_2 = 0x17,
                        LEVEL_OFFSET_1 = 0x1f,
                        DEBUG_INFO_1 = 0x1c,
                        AMBSHADOWS_OCCLUDER_INFO = 0x37,
                        JSON_DOC = 0x39,
                        TAG_INT = 0x26,
                        COLLISION_DATA_CLOTH = 0x9,
                        LEVEL_BOUNDING_BOX_DATA = 0x42,
                        REGION_TREE = 0xe,
                        ACTOR_FLAGS = 0x4a,
                        RES_ITEM_ART_ITEM = 0xb,
                        POPULATOR_1 = 0x47,
                        CINEMATIC_1 = 0x43,
                        FEATURE_DB_2 = 0x23,
                        ANIM = 0x29,
                        NAV_MESH_HEIGHT_MAP_TEX_1 = 0x4c,
                        FT_SVG = 0x50,
                        RIVER_SECTION = 0x11,
                        GEOMETRY_1 = 0x19,
                        TAG_FLOAT = 0x27,
                        TEXTURE_DICTIONARY = 0x40,
                        UI_TEXTURES_METADATA = 0x4b,
                        FOREGROUND_SECTION_2 = 0x6,
                        WATER_DATA = 0x24,
                        TAG_VEC4 = 0x28,
                        VIS_INFO_1 = 0x20,
                        BG_COLLISION_DEBUG_INFO = 0x4e,
                        SPAWNER_GROUP = 0xc,
                        TAG_STRING = 0x25,
                        NAV_LEDGE_GRAPH_1 = 0x22,
                        JOINT_HIERARCHY = 0x2b,
                        KD_TREE_1 = 0x41,
                        KD_TREE_2 = 0x45,
                        ANIM_GROUP = 0x2a,
                        ATTACHED_FG_MAPPING = 0x1a,
                        ANIM_STREAM = 0x33,
                        EFFECT_TABLE = 0x14,
                        BACKGROUND_SECTION = 0x4,
                        LEVEL_INFO_3 = 0x3b,
                        LEVEL_INFO_2 = 0x3a,
                        LEVEL_INFO_1 = 0x2e,
                        LEVEL_INFO_4 = 0x3c,
                        FOREGROUND_SECTION = 0x5,
                        NAME_TABLE_1 = 0x34,
                        PIXEL_SHADER_TABLE = 0x3,
                        MATERIAL_TABLE_1 = 0x13,
                        SHRUB_COLLECTION_2 = 0x1b,
                        COLLISION_DATA_FOREGROUND = 0x8
                    };

                    enum Status : uint8_t {
                        PackageStatusUnused = 0x0,
                        PackageStatusInvalid = 0x1,
                        PackageStatusFailedOptionalFile = 0x2,
                        PackageStatusLoading = 0x3,
                        PackageStatusLoaded = 0x4,
                        PackageStatusUnloading = 0x5
                    };

                    struct PakHeader 0x40 {
                        uint32_t m_magic;
                        uint32_t m_hdrSize;
                        uint32_t m_pakLoginTableIdx;
                        uint32_t m_pakLoginTableOffset;
                        uint32_t m_pageCt;
                        uint32_t m_pakPageEntryTableOffset;
                        uint32_t m_numPointerFixUpPages;
                        uint32_t m_pointerFixUpTableOffset;
                        uint32_t m_dataSize;
                        uint32_t m_LoginTableIdx;
                        uint32_t m_VramTableOffset;
                        uint32_t m_field2c;
                        uint32_t m_field30;
                        uint32_t m_field34;
                        uint32_t m_field38;
                        uint32_t m_hdrsizeleft;
                    };

                    struct PakPageEntry 0xc {
                        uint32_t m_resPageOffset;
                        uint32_t m_pageSize;
                        uint32_t m_owningPackageIndex;
                    };

                    struct ResPage{};

                    // Base struct for all resources in a package
                    struct ResItem 0x30 {
                        uint64_t m_resNameStrOffset;
                        uint32_t m_pageSize @ 0x10;
                        StringId64 m_ResourceId @ 0x18;
                        StringId64 m_resourceTypeId;
                        uint32_t m_field28;
                        uint32_t m_field2c;
                    };

                    struct PakVramItemTable 0x10 {
                        uint32_t m_nVramItems; // number of VRAM_DESC in the table
                        ResItem* m_items @ 0x8; // array of abstract base class
                    };

                    uint64_t m_field8 @ 0x8;
                    uint64_t m_size; // Chunk size
                    uint32_t m_numAllocatedPages;
                    uint32_t m_field1c;
                    uint32_t m_LoginTableFlags[0x258]; 
                    LoadingHeapMgr.LevelHeapType m_levelheaptype @ 0x980;
                    uint64_t m_ChunkSize @ 0x988;
                    uint32_t m_hdrSize;
                    uint32_t m_pageCt;
                    uint32_t m_dataSize;
                    uint32_t m_field99c;
                    uint32_t m_field9a0;
                    uint32_t m_field9a4;
                    uint64_t m_VirtualMemoryAddressRange;
                    gamelib.level.Level* m_Level; // level this package belongs to
                    char m_packname[0x80] @ 0x9c8 [[utf8*]];
                    StringId64 m_packid @ 0xa48;
                    char m_packfilepath[0x80] + 0x1 [[utf8*]];
                    StringId64 m_packfilepathid @ 0xad8;
                    PakVramItemTable* m_VramItemTable;
                    uint32_t m_numRequests; // number of requests for this package
                    Status m_status;
                } // package.cpp

                struct PakLoginTableEntry : Package.ResItem 0x10 {

                    struct ResourcePair {
                        uint32_t m_pageIdx;
                        uint32_t m_itemOfs;
                    };

                    uint32_t m_MaxResources; // max number of resources in this package
                    //uint32_t m_field4
                    ResourcePair m_wantedPage + 0x4; 
                };

                // 0x1b8 - t1x
                struct PackageProcessingInfo 0xad0 {
                    enum LoadingStatus : uint32_t {
                        LoadingPackageStatusUnused = 0x0,
                        LoadingPackageStatusError = 0x1,
                        LoadingPackageStatusInvalid = 0x2,
                        LoadingPackageStatusWanted = 0x3,
                        LoadingPackageStatusOpenFile = 0x4,
                        LoadingPackageStatusLoadingPakHeader = 0x5,
                        LoadingPackageStatusLoadingHeader = 0x6,
                        LoadingPackageStatusLoadingPages = 0x7,
                        LoadingPackageStatusLoadingVram = 0x8,
                        LoadingPackageStatusWaitingForVramPages = 0x9,
                        LoadingPackageStatusDataIsLoaded = 0xa,
                        LoadingPackageStatusWaitingForVramProcessing = 0xb,
                        LoadingPackageStatusDoingLogin = 0xc,
                        LoadingPackageStatusFinalizing = 0xd,
                        LoadingPackageStatusLoaded = 0xe,
                        LoadingPackageStatusWaitingForLogout = 0xf,
                        LoadingPackageStatusDoingLogout = 0x10,
                        LoadingPackageStatusWaitingForUnload = 0x11,
                        LoadingPackageStatusFailedOptionalFile = 0x12
                    };

                    struct ReadSlot : FileSystem.ReadOperation 0x8 {
                        void* m_ChunkCell;
                    };

                    Package* m_package;
                    LoadingStatus m_status;
                    uint64_t m_NumAsyncReadOps @ 0x210;
                    ReadSlot m_aReadOps[0x40];
                    FileSystem.ReadOnlyFileHandle m_File;
                    Package.PakHeader m_pakHdr;
                    uint32_t m_field78;
                    uint32_t m_field7c;
                    uint64_t m_field80;
                    uint64_t m_field88;
                    uint64_t m_field90;
                    uint64_t m_field98;
                    uint32_t m_fielda0;
                    uint32_t m_LoggedResourcesCounter;
                } // package-mgr.cpp

                struct PackageMgr 0x4f70 {

                    // kMaxNumPackagesAwaitingUnload = 0x800;
                    // kMaxSubPagesPerPackage = 0x258;

                    enum PackageCategory : uint32_t {
                        Initial = 0x0, // initial
                        GlobalPak = 0x1, // "~DATABRANCH/"
                        LevelPak = 0x2, // tied to the current level
                        DictPak = 0x3, // "-dict[...].pak"
                        PsoDictPak = 0x4 // "psodict-....pak"
                    };

                    struct Configuration 0x50 { 
                        uint32_t m_freepackageslots;
                        uint32_t m_allocationRingBufferSize;
                        regenny.shared.corelib.memory.Context m_RingBufferContext;
                        regenny.shared.corelib.memory.Context m_memoryContext;
                        void* m_GetGameFrameNumber @ 0x20; // function pointer
                        uint64_t* m_PackageLoginResFuncs @ 0x38; // functions pointer
                        LoadingHeapMgr.LevelHeapType m_levelheaptype;
                        bool m_field44;
                        bool m_AllowDebugPages;
                        bool m_field46;
                    };

                    struct PkgNameLookupEntry 0x38 {
                        PkgNameLookupEntry* m_next;
                        StringId64 m_key;
                        StringId64 m_hash;
                        uint64_t m_field20 @ 0x20;
                        uint64_t m_field28;
                        uint64_t m_capacity;
                    };

                    struct PkgNameLookupHdr 0x30 {
                        PkgNameLookupEntry** m_buckets;
                        uint64_t* m_bitMask;
                        PkgNameLookupEntry* m_freeList;
                        void* m_allocator;
                        uint32_t m_bucketMask;
                        uint32_t m_capacity @ 0x28;
                        uint32_t m_size;
                    };

                    struct PackageRequest 0xa0 {

                        enum RequestType : uint32_t {
                            Login = 0x0,
                            Logout = 0x1
                        };

                        RequestType m_RequestType;
                        StringId64 m_packid @ 0x8;
                        char m_name[0x80] [[utf8*]];
                        PackageCategory m_category;
                        uint32_t m_isNumberedPart;
                        gamelib.level.Level* m_Level;
                    };

                    struct PackageRequestInfo 0x18 {
                        uint32_t m_totalrequested;
                        uint32_t m_overallrequested;
                        uint32_t m_numPackagesRequested;
                        uint32_t m_maxrequestlimit;
                        PackageRequest* m_PackagesRequested; // array of PackageRequest
                    };

                    struct ProcessingRingBuffer 0x18 {
                        uint32_t m_head;
                        uint32_t m_tail;
                        uint32_t m_numQueued;
                        uint32_t m_capacity;
                        PackageProcessingInfo** m_slots;
                    };

                    struct IOStagingRing 0x20 {
                        uint32_t m_userFileOffset;
                        uint32_t m_streamBytesProduced;
                        uint32_t m_ringUsedBytes;
                        uint32_t m_streamSubmitOffset;
                        uint32_t m_ringTail;
                        uint32_t m_ringHead;
                        uint8_t* m_RingBuffer;
                    };

                    uint32_t m_freepackageslots;
                    uint32_t m_allocationRingBufferSize;
                    regenny.shared.corelib.memory.Context m_RingBufferContext;
                    regenny.shared.corelib.memory.Context m_memoryContext;
                    void* m_field30 @ 0x30; // function pointer
                    regenny.shared.gamelib.level.DataLoading.PackageDataLoadingVTable* m_PackageLoginResFuncs; // functions pointer
                    LoadingHeapMgr.LevelHeapType m_levelheaptype;
                    bool m_field44;
                    bool m_AllowDebugPages;
                    bool m_field46;
                    bool m_field48 + 0x1;
                    uint32_t m_filed4c @ 0x4c;
                    PackageRequestInfo m_RequestInfo;
                    Package* m_packages; // array of Package
                    PackageProcessingInfo* m_packageinfos; // array of PackageProcessingInfo
                    PkgNameLookupHdr m_pakNameLookup;
                    PkgNameLookupHdr m_nickNameLookup;
                    ProcessingRingBuffer m_processingLoadQueue @ 0xe0;
                    ProcessingRingBuffer m_processingUpdateQueue;
                    ProcessingRingBuffer m_processingUnloadQueue @ 0x130;
                    uint32_t m_loginStageFence;
                    bool m_forceReleaseVirtualMemory; // Force reload package from disk
                    regenny.shared.corelib.system.platform.ndsys.Mutex m_LoadingLock @ 0x480;
                    regenny.shared.corelib.system.platform.ndsys.ConditionVariable m_ConditionVariable;
                    regenny.shared.corelib.system.platform.ndsys.Mutex m_LoginLock;
                    IOStagingRing m_ioStagingRing;
                    uint32_t m_PendingPackageVramReleaseCount;
                    PackageProcessingInfo** m_PendingPackageVramRelease + 0x4;
                    bool m_filed4761 @ 0x4761;
                    bool m_field4762;
                } // package-mgr.cpp

                struct PrefetchMgr 0x9e0 {

                    struct PrefetchEntry {
                        uint8_t m_Flags;
                        uint8_t m_DirSlot;
                        uint16_t m_field02;
                        uint32_t m_field04; 
                        char* m_FileName [[utf8*]];
                    };

                    void* m_EntryTable;
                    void* m_EntryAux;
                    uint64_t m_PendingBits[0x5e];
                    uint32_t m_field300;
                    uint32_t m_MaxEntries;
                    FileSystem* m_FileSystem;
                    PackageMgr* m_PackageMgr;
                    char m_GameDataPath[0x400] @ 0x31c [[utf8*]];
                    uint32_t m_GameDataPathLen;
                    bool m_UseGameDataPrefix;
                    bool m_Paused;
                    uint32_t m_QueueHead @ 0x750;
                    uint32_t m_field754;
                    uint32_t m_FileNamePoolHead;
                    uint32_t m_DirSlotCount;
                    void* m_DirTable;
                    void* m_FileNamePool;
                    uint32_t m_FileNamePoolCapacity;
                    uint32_t m_FileNameHighWater;
                    uint32_t m_FileNameUsed;
                    corelib.system.platform.ndsys.Thread m_Threads[0x1f] @ 0x780;
                    corelib.system.platform.ndsys.Mutex m_PrefetchAccessLock;
                    corelib.system.platform.ndsys.ConditionVariable m_PrefetchCondVar;
                    bool m_ShutdownRequested;
                }; // prefetch.cpp
            }

        }

        // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\gamelib
        namespace gamelib {

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\gamelib\level
            namespace level {

                struct DataLoading {
                    struct Config 0x20 {
                        uint32_t m_memsize;
                        uint32_t m_freepackageslots;
                        uint32_t m_field8;
                        uint32_t m_fieldc;
                        uint32_t m_field10;
                        uint32_t m_field14;
                        uint32_t m_field18;
                        uint32_t m_field1c;
                    };

                    struct PackageDataLoadingVTable {
                        virtual bool PackageLoginResItem(ndlib.io.Package* pPackage, ndlib.io.Package.ResItem* pResItem) @ 0
                        /*
                        void* data_????????? = FinalizePackageLogin
                        void* data_????????? = bool __cdecl PreparePackageForLogout(class PackageMgr *,class Package *)
                        void* data_????????? = sub_?????????
                        void* data_????????? = void __cdecl TextureMgrPub::Unload(class Package *,const struct PakVramItemTable *)
                        void* data_????????? = sub_?????????
                        void* data_????????? = bool __cdecl RunBeginVramLoadingCmd(struct PackageManagerCmd *)
                        void* data_????????? = void __cdecl VramPageConsumed(void *)
                        void* data_????????? = void __cdecl TextureMgrPub::Cmd(const struct PackageManagerCmd &)
                        void* data_????????? = sub_?????????
                        */
                        virtual void ReleaseLoadedVramPages() @ 10
                    } 

                }; // data-loading.cpp

                // Not Researched (placeholder yet)
                struct LevelMgr 0x481f20 {

                    struct Configuration 0x10 {
                        uint32_t m_field0;
                        uint32_t m_field4;
                        uint32_t m_field8;
                        uint32_t m_fieldc;
                    };

                    corelib.containers.FixedSizeHeap m_heap; // possibly for levels
                    void* m_field60 @ 0x60;  
                }; // level-mgr.cpp
                
                // Not Researched (placeholder yet)
                struct Level 0xac0 {
                    char* m_PackageName @ 0x48 [[utf8*]];
                    StringId64 m_PackageId;
                    void* m_pFgGeometry @ 0xf8;
                    void* m_pEntitySpawners;
                    void* m_field108;
                    void* m_field110;
                    void* m_ppLightTables;
                    void* m_field120;
                    void* m_field128;
                    void* m_pBackground;
                }; // level.cpp

                struct GameLoading {

                    enum TransitionStatus : uint32_t {
                        // Idle / finished:
                        kSteady = 0x00, // WaitForSteadyState() waits for this

                        // Early pipeline stages scheduled by UpdateInternal():
                        kMountWorld = 0x01, // schedules GameLoadingMountWorld
                        kMountLanguage = 0x02, // schedules GameLoadingMountLanguage
                        kMountSPMP = 0x03, // schedules GameLoadingMountSPMP
                        kCopyToHDD = 0x04, // schedules GameLoadingCopyToHDD
                        kPlayGoWait = 0x05, // schedules GameLoadingPlayGoWait
                        kPlayGoWait_Alias = 0x06, // alias into PlayGo wait path (same dispatch)

                        // Set once the initial-archives job finishes its countdown:
                        kMountedInitial = 0x07,
                        // Initial-archives countdown sequence stages:
                        kMountingOthers = 0x08, // WaitForFirstWorldAvailability()
                        kMountingFirstWorld = 0x09, // ...
                        kMountingSPCommon = 0x0A, // ...
                        kMountingMPCommon = 0x0B, // ...
                        kMountingCommon = 0x0C, // WaitForCommonAvailability()
                        kMountingCore = 0x0D, // WaitForCoreAvailability()
                        kMountingBin = 0x0E, // ...
                    };

                    enum SpMpMode : uint32_t {
                        kModeNone = 0x0, 
                        kModeSP = 0x1, // Single-player
                        kModeMP = 0x2  // Multi-player
                    };

                    // Intrusive nodes allocated by LoadChunksTxt()
                    // name -> bitset of chunk IDs
                    struct ChunkSetNode 0x30 {
                        ChunkSetNode* m_next;
                        ChunkSetNode* m_prev;
                        char* m_name [[utf8*]]; 
                        uint64_t m_chunkMaskLo;
                        uint64_t m_chunkMaskHi;
                    };

                    // id -> name
                    struct ChunkIdNode 0x20 {
                        ChunkIdNode* m_next;
                        ChunkIdNode* m_prev;
                        uint32_t m_id;
                        char* m_name @ 0x18 [[utf8*]];
                    };

                    // Global/Statics:
                    // - Initial archive pipeline: bin, shaders, common, mp-common, sp-common, first world, dicts.
                    // - World switch is driven by Current/Target name pairs; UpdateInternal schedules MountWorld when they differ.
                    // - Chunk DB uses FixedSizeHeap + hash buckets with the two intrusive node types above.
                    //   Buckets: ChunkIdNode** and ChunkSetNode** (array of heads); list heads: ChunkIdNode*/ChunkSetNode*.
                    // - KMaxCoreArchives = 0x64.
                    // - Job counters: g_pGameLoadingState, g_pStepCounter
                    // - Mutexes: g_PlayGoSpeedMutex, g_PlayGoChunkAvailMutex
                    // - Core archives: g_NumCoreArchives (KMaxCoreArchives = 0x64), g_CoreArchives[]
                    // - World selection: g_WorldNameCurrent/Target, g_WorldCompanionNameCurrent/Target, g_WorldNamePrevious
                    // - SP/MP mode: g_SpMpModeDesired, g_SpMpModeCurrent (GameLoading::SpMpMode)
                    // - Copy/PlayGo flags: g_CopyPhaseFlags/Target; PlayGoFlag{1,2,3}_{Curr,Target}
                    // - Chunk availability: bitset for IDs; event ring (read/write/count/capacity/data)
                    // - Lang & SP/MP slots: Language A/B, TTS menu/gameplay, SPMP A/B/C

                }; // game-loading.cpp

            };

            // c:\branches\discbot??\t2r-pc-?.?.?\shared\src\gamelib\state-script
            namespace state_script {
                struct ScriptCFuncContext 0x208 {
                    ndlib.script.ScriptValue m_args;
                };

                struct CFunctionStack 0x40 {
                    ScriptCFuncContext* m_pScriptCFuncContext;
                    uint32_t m_NumArgs; // number of received arguments
                    uint32_t m_field_c;
                    uint32_t m_FunctionArgs; // number of function arguments (expected)
                    uint64_t m_field_18 @ 0x18;
                    uint64_t m_field_20;
                    uint64_t m_field_28;
                    bool m_field_30;
                    bool m_MakeAllErrorsFatal;
                };
            }
        }
        
    }

    // c:\branches\discbot??\t2r-pc-?.?.?\t2r\src
    namespace ndgame {
        
        // c:\branches\discbot??\t2r-pc-?.?.?\t2r\src\game
        namespace game {

            struct GameInfo : shared.ndlib.NdGameInfo 0x580 {
                bool m_enableNpTrophies + 0x148  [[bool*]];
                uint64_t m_field4Bd8 @ 0x4bd8;
            }

            struct FrameState : shared.ndlib.NdFrameState 0x168 {
                uint64_t Unk[0x2d];
            } 
        }
        
    }

}
